<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<AllTestDescription>
  <homework id="1" name="Арифметика">
    <test id="2" subject="Шашки" testSetFolder="checkers">
      <description><![CDATA[На доске стоит белая шашка. Требуется определить, может ли она попасть в заданную клетку, делая ходы по правилам, не превращаясь в дамку.
Вводится клетка, где стоит шашка, а затем клетка, куда шашка должна попасть.
Каждая клетка описывается номером вертикали, а затем номером горизонтали.
Выведите слово YES, если шашка может попасть из начальной клетки в указанную, и NO в противном случае.
*Пример 1*
+Ввод+	
1
1
8
8
+Вывод+
YES
*Пример 2*
+Ввод+	
2
2
1
1
+Вывод+
NO
]]></description>
    </test>
    <test id="3" subject="Ход короля" testSetFolder="kingMove">
      <description/>
    </test>
    <test id="4" subject="Складирование ноутбуков" testSetFolder="packingNotebooks">
      <description><![CDATA[На склад, который имеет форму прямоугольного параллелепипеда, привезли ноутбуки, упакованные в коробки. Каждая коробка также имеет форму прямоугольного параллелепипеда. По правилам хранения коробки с ноутбуками должны быть размещены на складе с выполнением следующих двух условий:
- Стороны коробок должны быть параллельны сторонам склада.
- Коробку при помещении на склад разрешается расположить где угодно (с выполнением предыдущего условия), в том числе на другой коробке, но все коробки должны быть ориентированы одинаково (т.е. нельзя одну коробку расположить “стоя”, а другую —“лежа”)
Напишите программу, которая по размерам склада и размерам коробки с ноутбуком определит максимальное количество ноутбуков, которое может быть размещено на складе.
Программа получает на вход шесть натуральных чисел. Первые три задают длину, высоту и ширину склада. Следующие три задают соответственно длину, высоту и ширину коробки с ноутбуком.
Программа должна вывести одно число — максимальное количество ноутбуков, которое может быть размещено на складе.
*Пример 1*
+Ввод+	
100
200
300
1
2
3
+Вывод+
1000000]]></description>
    </test>
    <test id="5" subject="Сложное уравнение" testSetFolder="complexEquatation">
      <description><![CDATA[Решить в целых числах уравнение:
(ax+b)/(cx+d) = 0
*Формат ввода*
Вводятся 4 числа: a, b, c, d; c и d не равны нулю одновременно.
*Формат вывода*
Необходимо вывести все решения, если их число конечно, “NO” (без кавычек), если решений нет, и “INF” (без кавычек), если решений бесконечно много.]]></description>
    </test>
    <test id="6" subject="МКАД" testSetFolder="mkad">
      <description><![CDATA[Ограничение времени	1 секунда
Ограничение памяти	64Mb
Длина Московской кольцевой автомобильной дороги — 109 километров. Байкер Вася стартует с нулевого километра МКАД и едет со скоростью v километров в час. На какой отметке он остановится через t часов?
Формат ввода
Программа получает на вход значение v и t. Если v > 0, то Вася движется в положительном направлении по МКАД, если же значение v < 0, то в отрицательном. (Гарантируется, что исходные числа — целые и находятся в промежутке от -1000 до +1000).
Формат вывода
Программа должна вывести целое число от 0 до 108 — номер отметки, на которой остановится Вася.
*Пример*
+Ввод+	
60
2
+Вывод+
11]]></description>
    </test>
    <test id="7" subject="Спички" testSetFolder="matches">
      <description><![CDATA[Вдоль прямой выложены три спички. Необходимо переложить одну из них так, чтобы при поджигании любой спички сгорали все три. Для того чтобы огонь переходил с одной спички на другую, необходимо чтобы эти спички соприкасались (хотя бы концами).
Требуется написать программу, определяющую, какую из трех спичек необходимо переместить.
Формат ввода
Вводятся шесть целых чисел через пробел: l1, r1, l2, r2, l3, r3 –– координаты первой, второй и третьей спичек соответственно (0 <= l < r <= 100). Каждая спичка описывается координатами левого и правого концов по горизонтальной оси OX.
Выведите номер искомой спички. Если возможных ответов несколько, то выведите наименьший из них. В случае, когда нет необходимости перемещать какую-либо спичку, выведите 0. Если же требуемого результата достигнуть невозможно, то выведите -1.
*Пример 1*
+Ввод+
0
2
4
5
3
6
+Вывод+
1
*Пример 2*
+Ввод+	
1
2
9
10
12
20
+Вывод+
3
]]></description>
    </test>
    <test id="8" subject="Подсчет единичных битов" testSetFolder="countNonZeroBytes">
      <description><![CDATA[Дано натуральное число меньше 16. Посчитать количество его единичных битов. Например, если дано число 9, запись которого в двоичной системе счисления равна 1001, то количество его единичных битов равно 2.]]></description>
    </test>
    <test id="9" subject="Простой переворот числа" testSetFolder="simpleTransform">
      <description><![CDATA[Сформировать число, представляющее собой обратную в порядке следования разрядов запись введенного трехзначного числа. Например, для числа 345 таким будет 543.]]></description>
    </test>
  </homework>
  <homework id="10" name="Циклы и Строки">
    <test id="11" subject="Перестановка слов" testSetFolder="hw2Changewords">
      <description><![CDATA[Дана строка, состоящая ровно из двух слов, разделенных пробелом. Переставьте эти слова местами. Результат запишите в строку и выведите получившуюся строку. При решении этой задачи нельзя пользоваться циклами и инструкцией if.
+Пример+ 
*Ввод*	
Hello, world!
*Вывод*
world! Hello,]]></description>
    </test>
    <test id="12" subject="Замена фрагмента" testSetFolder="hw2ChangeFragment">
      <description><![CDATA[Вводится строка. 
Нужно заменить в этой строке все появления буквы h на букву H, кроме первого и последнего вхождения.
Ответ необходимо выводить в виде распечатки одной переменной строкового типа.
System.out.println(resStr);
resStr - итоговая строка, имя переменной любое осмысленное.
+Пример+
*Ввод*
In the hole in the ground there lived a hobbit.
*Вывод*
In the Hole in tHe ground tHere lived a hobbit.
]]></description>
    </test>
    <test id="13" subject="Удаление символа" testSetFolder="hw2RemoveSymbol">
      <description><![CDATA[Вводится строка. 
Нужно удалить из этой строки все символы @.
Ответ необходимо выводить в виде распечатки одной переменной строкового типа.
System.out.println(resStr);
resStr - итоговая строка, имя переменной любое осмысленное.]]></description>
    </test>
    <test id="14" subject="Вставка символа" testSetFolder="hw2InsertSymbol">
      <description><![CDATA[Дана строка. Получите новую строку, вставив между символами исходной строки символ *. Выведите полученную строку.
Пример 
Ввод:
Python
Вывод:
P*y*t*h*o*n]]></description>
    </test>
    <test id="15" subject="Удаление каждого третьего" testSetFolder="hw2RemoveEachThird">
      <description><![CDATA[Дана строка. Удалите из нее все символы, чьи индексы делятся на 3. Символы строки нумеруются, начиная с нуля.
Пример:
Ввод	
Python
Вывод
yton
]]></description>
    </test>
    <test id="16" subject="Наименьшее расстояние между локальными максимумами" testSetFolder="hw2Maximums">
      <description><![CDATA[Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел, завершающейся числом 0. Локальным максимумом называется такое число в последовательности, которое больше своих соседей. Если в последовательности нет двух локальных максимумов, выведите число 0. Начальное и конечное значение при этом локальными максимумами не считаются.
Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
Пример 
Ввод	
1
2
1
1
*2*
1
*2*
1
0
Вывод:
2
]]></description>
    </test>
    <test id="17" subject="Идеальный исполнитель" testSetFolder="hw2IdealExecutor">
      <description><![CDATA[Исполнитель “Раздвоитель” преобразует натуральные числа. У него есть две команды: “Вычесть 1” и “Разделить на 2”, первая команда уменьшает число на 1, вторая команда уменьшает число в два раза, если оно чётное, иначе происходит ошибка. Дано два натуральных числа A и B (A>B). 
Напишите алгоритм для "Раздвоителя", который преобразует число A в число B и при этом содержит минимальное число команд. Команды алгоритма нужно выводить по одной в строке, первая команда обозначается, как -1, вторая команда как :2.
Вводятся два натуральных числа A и B.
Выведите ответ на задачу.
Пример 1
Ввод	
179
20
Вывод
-1
:2
-1
:2
:2
-1
-1
]]></description>
    </test>
    <test id="18" subject="Пробежка по утрам" testSetFolder="hw2MorningRun">
      <description><![CDATA[В первый день спортсмен пробежал x километров, а затем он каждый день увеличивал пробег на 10% от предыдущего значения. По данному числу y определите номер дня, на который пробег спортсмена составит не менее y километров.
Программа получает на вход действительные числа x и y
Программа должна вывести одно натуральное число.
Пример 
Ввод	
10
20
Вывод
9]]></description>
    </test>
    <test id="19" subject="Второй максимум" testSetFolder="hw2SecondMax">
      <description><![CDATA[Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине элемента в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить наибольший элемент.
Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
Выведите ответ на задачу.
Пример
Ввод	
1
7
9
0
Вывод
7
]]></description>
    </test>
    <test id="20" subject="Количество палиндромов" testSetFolder="hw2Palindroms">
      <description><![CDATA[Назовем число палиндромом, если оно не меняется при перестановке его цифр в обратном порядке. Напишите программу, которая по заданному числу K выводит количество натуральных палиндромов, не превосходящих K.
Формат ввода
Задано единственное число K (1 ≤ K ≤ 100 000).
Формат вывода
Необходимо вывести количество натуральных палиндромов, не превосходящих K.
Пример 1
Ввод	
1
Вывод
1
Пример 2
Ввод	
100
Вывод
18
Пример 3
Ввод	
10
Вывод
9
]]></description>
    </test>
    <test id="21" subject="Заменить пробел и группы пробелов символом &quot;*&quot;" testSetFolder="changeSpacesToStars">
      <description><![CDATA[Дана строка слов, разделенных пробелами. Между словами может быть один или несколько пробелов, требуется заменить одиночный пробел или группу пробелов на символ "*". 
*Пример*
+Ввод+
мама мыла    раму
Вывод
мама*мыла*раму]]></description>
    </test>
    <test id="22" subject="Номера групп" testSetFolder="correctGroupNames">
      <description><![CDATA[Требуется проверить, встречаются ли в массиве исходных строк номера групп. 
Номер группы имеют вид: М3О-NNNБ-MM, где N - любая цифра, ММ - две последние цифры года поступления (могут принимать значения только 14, 15, 16, 17, 18, 19).
Формат ввода: количество строк, строки (каждая в отдельной строке).
Формат вывода: строки, являющиеся корректными номерами групп (каждая в отдельной строке).
+Пример+
*Ввод*
8
6ПВК-111
М3О-235Б-18
4БИТ007
4БИТ-006
М3О-235  Б-18
4BIT - 006
М3О-236Б-18
4-BIT-123
*Вывод*
М3О-235Б-18
М3О-236Б-18
]]></description>
    </test>
    <test id="23" subject="Простая проверка слов" testSetFolder="simpleTestOfWords">
      <description><![CDATA[Пользователь вводит 10 слов. 
Определить, сколько из них начинаются с буквы 'S', содержат букву "i" и имеют длину 6 букв. 
Формат ввода: 10 слов, каждое в отдельной строке.
Формат вывода: количество найденных слов.]]></description>
    </test>
  </homework>
  <homework id="24" name="Функции">
    <test id="25" subject="Принадлежит ли точка области?" testSetFolder="isPointInArea">
      <description><![CDATA[Проверьте, принадлежит ли точка данной закрашенной области:
Если точка принадлежит области (область включает границы), выведите слово YES, иначе выведите слово NO. Решение должно содержать функцию isPointInArea(x, y), возвращающую True, если точка принадлежит области и False, если не принадлежит. Основная программа должна считать координаты точки, вызвать функцию isPointInArea и в зависимости от возвращенного значения вывести на экран необходимое сообщение. Функция isPointInArea не должна содержать инструкцию if.
!https://i.ibb.co/6ZSmwh9/area.png!
Формат ввода
Вводится два действительных числа.
Выведите ответ на задачу.
*Пример*
+Ввод+	
-4
-4
+Вывод+
NO]]></description>
    </test>
    <test id="26" subject="Принадлежит ли точка квадрату?" testSetFolder="isPointInSquare">
      <description><![CDATA[Даны два действительных числа x и y. Проверьте, принадлежит ли точка с координатами (x,y) заштрихованному квадрату (включая его границу). Если точка принадлежит квадрату, выведите слово YES, иначе выведите слово NO. На рисунке сетка проведена с шагом 1.
Решение должно содержать функцию isPointInSquare(x, y), возвращающую True, если точка принадлежит квадрату и False, если не принадлежит. Основная программа должна считать координаты точки, вызвать функцию isPointInSquare и в зависимости от возвращенного значения вывести на экран необходимое сообщение.
Функция isPointInSquare не должна содержать инструкцию if.
!https://i.ibb.co/6P5Rqqw/1x1.png!
*Пример*
+Ввод:+
1
1
+Вывод:+
NO]]></description>
    </test>
    <test id="27" subject="Разворот последовательности" testSetFolder="reverseInput">
      <description><![CDATA[Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту последовательность в обратном порядке. При решении этой задачи нельзя пользоваться массивами и прочими динамическими структурами данных. Рекурсия вам поможет.
*Пример* 
+Ввод+	
1
2
3
0
+Вывод+
0
3
2
1]]></description>
    </test>
    <test id="28" subject="Алгоритм Евклида" testSetFolder="gcdEvklid">
      <description><![CDATA[Для быстрого вычисления наибольшего общего делителя двух чисел используют алгоритм Евклида. Он построен на следующем соотношении НОД(a,b) = НОД(b, a mod b)
Реализуйте рекурсивный алгоритм Евклида в виде функции gcd(a, b).
*Пример* 
+Ввод+	
12
8
+Вывод+
4]]></description>
    </test>
    <test id="29" subject="Рекурсивное сложение" testSetFolder="sumNoAdd">
      <description/>
    </test>
    <description><![CDATA[Написать рекурсивную функцию summ(a, b), возвращающую сумму двух целых неотрицательных чисел. Из всех арифметических операций допускаются только +1 и -1. Также нельзя использовать циклы. ]]></description>
    <test id="30" subject="Сумма факториалов" testSetFolder="summOfFactorials">
      <description><![CDATA[По данному натуральном n вычислите сумму:
1! + 2! + 3! + .. + n!
В решении этой задачи можно использовать только *один* цикл.
Формат ввода
Вводится натуральное число n.
Формат вывода
Выведите ответ на задачу.
*Пример 1*
+Ввод+	
1
+Вывод+
1
*Пример 2*
+Ввод+	
2
+Вывод+
3]]></description>
    </test>
    <test id="31" subject="Только квадраты" testSetFolder="squaresOnly">
      <description><![CDATA[Напишите программу, которая выбирает из полученной последовательности квадраты целых чисел выводит их в обратном порядке. Использовать массив для хранения последовательности +не разрешается.+
*Формат ввода*
Во входных строках записаны целые числа, по одному в каждой строке. В последней строке записано число 0.
*Формат вывода*
Программа должна вывести элементы полученной последовательности, которые представляют собой квадраты целых чисел, в обратном порядке в одну строчку, разделив их пробелами. Если таких нет, программа должна вывести число 0.
*Пример 1*
+Ввод+
1
2
3
4
0
+Вывод+
4 1
*Пример 2*
Ввод	
3
5
0
Вывод
0
*Пример 3*
Ввод	
777
66883
0
Вывод
0]]></description>
    </test>
  </homework>
  <homework id="32" name="Массивы">
    <test id="33" subject="Ферзи" testSetFolder="eightQueens">
      <description><![CDATA[Известно, что на шахматной доске 8×8 можно расставить 8 ферзей так, чтобы они не атаковали друг друга. Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара "бьющих" друг друга.
+Формат ввода+
Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей.
+Формат вывода+
Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.
*Пример 1*
Ввод
1 7
2 4
3 2
4 8
5 6
6 1
7 3
8 5
Вывод
NO
*Пример 2*
Ввод
1 8
2 7
3 6
4 5
5 4
6 3
7 2
8 1
Вывод
YES]]></description>
    </test>
    <test id="34" subject="Четные индексы" testSetFolder="evenElementsByIndex">
      <description><![CDATA[<pre>
Выведите все элементы списка с четными индексами (то есть A[0], A[2], A[4], ...). Программа должна быть эффективной и не выполнять лишних действий!
Формат ввода
В первой строке вводится количество чисел в списке.
В следующей строке вводится список чисел. Все числа списка находятся на одной строке.
Пример 
Ввод
5
1 2 3 4 5
Вывод
1 3 5
</pre> ]]></description>
    </test>
    <test id="35" subject="Больше соседей" testSetFolder="greaterThanNeighbors">
      <description><![CDATA[Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей и выведите количество таких элементов.
+Формат ввода+
В первой строке вводится количество чисел в списке.
В следующей строке вводится список чисел. Все числа списка находятся на одной строке.
Выведите ответ на задачу.
*Пример 1*
Ввод
5
1 2 3 4 5
Вывод
0
*Пример 2*
Ввод
5
5 4 3 2 1
Вывод
0
*Пример 3*
Ввод	
5
1 5 1 5 1
Вывод
2]]></description>
    </test>
    <test id="36" subject="Количество совпадающих пар" testSetFolder="numberOfEqualPairs">
      <description><![CDATA[Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
+Формат ввода+
В первой строке вводится количество чисел в списке.
В следующей строке вводится список чисел. Все числа списка находятся на одной строке.
Выведите ответ на задачу.
*Пример 1*
Ввод
5
1 2 3 2 3
Вывод
2
*Пример 2*
Ввод
5
1 1 1 1 1
Вывод
10
*Пример 3*
Ввод	
3
1 2 3
Вывод
0
]]></description>
    </test>
    <test id="37" subject="Диофантово уравнение" testSetFolder="diofantEquatation">
      <description><![CDATA[Даны числа a, b, c, d, e. Подсчитайте количество таких целых чисел от 0 до 1000, которые являются корнями уравнения (ax3+bx2+cx+d)/(x-e)=0, и выведите их количество.
*Пример 1*
Ввод
1 -2 1 0 1
Вывод
1
*Пример 2*
Ввод
1 1 1 1 1
0]]></description>
    </test>
    <test id="258" subject="Почти отсортирован" testSetFolder="almostSorted">
      <description><![CDATA[
Quote
Description
Определите, можно ли вычеркнуть из данного массива одно число так, чтобы оставшиеся числа оказались упорядоченными по возрастанию.
+Пример1:+
Ввод:
1 2 5 3 4
Вывод:
Yes
+Пример2:+
Ввод:
1 2 3 4
Вывод:
Yes (Вычеркиваем любой элемент и массив остается упорядоченным)
+Пример3:+
Ввод:
4 3 2 1
Вывод:
No]]></description>
    </test>
  </homework>
  <homework id="38" name="Поиск и сортировка">
    <test id="39" subject="Последний максимум" testSetFolder="lastMaxValue">
      <description><![CDATA[Найдите *наибольшее значение* в списке и *индекс* последнего элемента, который имеет данное значение за один проход по списку, не модифицируя этот список и не используя дополнительного списка.
Выведите два значения.
*Пример*
+Ввод+	
1 2 1 2 1
+Вывод+
2 3
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.]]></description>
    </test>
    <test id="40" subject="Сортировка подсчетом" testSetFolder="countSort">
      <description><![CDATA[Дан список из N (N ≤ 2 * 105) элементов, которые *принимают целые значения от 0 до 100*.
Отсортируйте этот список в порядке неубывания элементов, используя алгоритм сортировки с подсчетом. 
Выведите полученный список.
Решение оформите в виде функцииcountSort(A), которая *модифицирует* передаваемый ей список. Использовать встроенные функции сортировки нельзя.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+	
7 3 4 2 5
+Вывод+
2 3 4 5 7
*Пример 2*
+Ввод+	
1 2 3 4 5 6 7 8 9 10
+Вывод+
1 2 3 4 5 6 7 8 9 10
*Пример 3*
+Ввод+	
9 8 7 6 5 4 3 2 1 0
+Вывод+
0 1 2 3 4 5 6 7 8 9
]]></description>
    </test>
    <test id="41" subject="Максимальный балл по классам" testSetFolder="maxInClass">
      <description><![CDATA[В олимпиаде по информатике принимало участие несколько человек. Победителем олимпиады становится человек, набравший больше всех баллов. Победители определяются независимо по каждому классу. Определите количество баллов, которое набрал победитель в каждом классе. Гарантируется, что в каждом классе был хотя бы один участник.
+Формат ввода+
Информация о результатах олимпиады представлена списком, каждая строка которого имеет вид: фамилия имя класс балл.
Фамилия и имя — текстовые данные, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от 0 до 100.
+Формат вывода+
Выведите три числа: баллы победителя олимпиады по 9 классу, по 10 классу, по 11 классу. 
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+
Иванов Сергей 9 90
Сергеев Петр 10 91
Петров Василий 11 92
Васильев Иван 9 93
+Вывод+
93 91 92]]></description>
    </test>
    <test id="42" subject="Школы с наибольшим числом участников олимпиады" testSetFolder="schoolsWithMaxParticipants">
      <description><![CDATA[В олимпиаде по информатике принимало участие N человек. Определите школу(или школы), из которых в олимпиаде принимало участие больше всего участников. В этой задаче необходимо считывать данные построчно, не сохраняя в памяти данные обо всех участниках, а только подсчитывая число участников для каждой школы.
+Формат ввода+
Информация о результатах олимпиады представлена в виде списка, каждая запись которого имеет формат: фамилия имя школа балл.
Фамилия и имя — текстовые строки, не содержащие пробелов. Школа — целое число от 1 до 99. Балл — целое число от 0 до 100.
+Формат вывода+
Выведите номера школ(или школы) с максимальным числом участников в порядке возрастания баллов, если их несколько.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+	
Иванов Сергей 14 99
Сергеев Петр 23 74
Петров Василий 3 99
Васильев Андрей 3 56
Андреев Роман 14 75
Романов Иван 27 68
+Вывод+
3 14 
*Пример 2*
+Ввод+	
Иванов Сергей 10 43
Сергеев Петр 20 24
Петров Василий 45 74
Васильев Андрей 10 24
Андреев Александр 15 45
Александров Роман 14 35
Романов Иван 11 45
Алексеев Сергей 10 56
Егоров Николай 1 56
Николаев Степан 3 15
+Вывод+
10 ]]></description>
    </test>
    <test id="43" subject="Гражданская оборона(*)" testSetFolder="civilDefense">
      <description><![CDATA[Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все *n* селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены *m* бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить ближайшее к нему бомбоубежище.
+Формат ввода+
В первой строке вводится число n - количество селений (1 <= n <= 100000). Вторая строка содержит n различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения. В третьей строке входных данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 109. Селение и убежище могут располагаться в одной точке.
+Формат вывода+
Выведите n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+	
4
1 2 6 10
2
7 3
+Вывод+
2 2 1 1 
*Пример 2*
+Ввод+	
1
1
1
2
+Вывод+
1 
*Пример 3*
+Ввод+	
10
79 64 13 8 38 29 58 20 56 17
10
53 19 20 85 82 39 58 46 51 69
+Вывод+
5 10 2 2 6 3 7 3 7 2 
]]></description>
    </test>
  </homework>
  <homework id="44" name="Множества">
    <test id="45" subject="Телефонные номера" testSetFolder="phoneNumbers">
      <description><![CDATA[<pre>Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов: 
+7<код><номер>
8<код><номер> <номер>, где <номер> — это семь цифр, а <код> — это три цифры или три цифры в круглых скобках. Если код не указан, то считается, что он равен 495.
Кроме того, в записи телефонного номера может стоять знак “-” между любыми двумя цифрами (см. пример). 
На данный момент в адресной книге телефона Васи записано всего три телефонных номера, и он хочет записать туда еще один. Но он не может понять, не записан ли уже такой номер в телефонной книге. Помогите ему! Два телефонных номера совпадают, если у них равны коды и равны номера. Например, +7(916)0123456 и 89160123456 — это один и тот же номер.
+Формат ввода+
В первой строке входных данных записан номер телефона, который Вася хочет добавить в адресную книгу своего телефона. В следующих трех строках записаны три номера телефонов, которые уже находятся в адресной книге телефона Васи. Гарантируется, что каждая из записей соответствует одному из приведенных в условии форматов.
+Формат вывода+
Для каждого телефонного номера в адресной книге выведите YES (заглавными буквами), если он совпадает с тем телефонным номером, который Вася хочет добавить в адресную книгу или NO (заглавными буквами) в противном случае.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+
8(495)430-23-97
+7-4-9-5-43-023-97
4-3-0-2-3-9-7
8-495-430
+Вывод+
YES
YES
NO
</pre>]]></description>
    </test>
    <test id="46" subject="Количество совпадающих" testSetFolder="equalElements">
      <description><![CDATA[Даны два списка чисел, которые могут содержать до 100000 чисел каждый. Найдите числа, которые  содержатся одновременно как в первом списке, так и во втором.
+Формат ввода+
Вводятся два списка чисел. Все числа каждого списка находятся на отдельной строке.
+Формат вывода+
Выведите совпадающие числа в порядке возрастания.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример*
+Ввод+
1 2 3 2 1
2 3 4 3 2
+Вывод+
2 3]]></description>
    </test>
    <test id="47" subject="Количество слов в тексте" testSetFolder="numberOfDifferentWordsInText">
      <description><![CDATA[Во входном файле записан текст. Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Определите, сколько различных слов содержится в этом тексте.
+Формат ввода+
Вводится текст.
+Формат вывода+
Выведите ответ на задачу.
Читать из файла не требуется, достаточно читать входной поток. (Например, функцией _input_)]]></description>
    </test>
    <test id="48" subject="Количество различных чисел" testSetFolder="NumberOfVariousNumersInARow">
      <description><![CDATA[Дан список чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел.
+Формат ввода+
Вводится список целых чисел. Все числа списка находятся на одной строке.
+Формат вывода+
Выведите ответ на задачу.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.]]></description>
    </test>
    <test id="49" subject="Пересадки" testSetFolder="connectingRoutes">
      <description><![CDATA[На Новом проспекте для разгрузки было решено пустить два новых автобусных маршрута на разных участках проспекта.  Известны конечные остановки каждого из автобусов. Определите количество остановок, на  которых можно пересесть с одного автобуса на другой.
+Формат ввода+
Вводятся четыре числа, не превосходящие 100, задающие номера конечных остановок. Сначала для первого, потом второго автобуса (см. примеры и рисунок).
+Формат вывода+
Ваша программа должна выводить одно число – искомое количество остановок.  
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+
3 6 4 2
+Вывод+
2
*Пример 2*
+Ввод+
3 1 5 10
+Вывод+
0
Пояснения:
*Первый пример* (см. рисунок): первый автобус ходит с 3-й остановки по 6-ю и обратно, а второй с 2-й по 4-ю и обратно. Пересесть с одного автобуса на другой можно на 3-й и 4-й остановках. Их две. 
*Второй пример*: автобусы не имеют общих остановок.
!https://preview.ibb.co/k7yMAf/stops.gif!]]></description>
    </test>
    <test id="50" subject="Забастовки" testSetFolder="strikes">
      <description><![CDATA[Политическая жизнь одной небольшой страны очень оживленная. В стране действует K политических партий, каждая из которых регулярно объявляет национальную забастовку. Дни, когда хотя бы одна из партий объявляет забастовку, при условии, что это не суббота или воскресенье (когда и так никто не работает), наносят большой ущерб экономике страны. 
i-я партия объявляет забастовки строго каждые bi дней, начиная с дня с номером ai. То есть i-я партия объявляет забастовки в дни ai, ai+bi, ai+2bi и т.д.
Если в какой-то день несколько партий объявляет забастовку, то это считается одной общенациональной забастовкой. В календаре страны N дней, пронумерованных от 1 до N. Первый день года является понедельником, шестой и седьмой дни года — выходные, неделя состоит из семи дней.
*Формат ввода*
Программа получает на вход число дней в году N (1≤ N≤10^6) и число политических партий K (1≤ K≤100). Далее идет K строк, описывающие графики проведения забастовок. i-я строка содержит числа ai и bi (1≤ ai, bi≤ N).
*Формат вывода*
Выведите единственное число: количество забастовок, произошедших в течение года.
Пример 1
Ввод	
19 3
2 3
3 5
9 8
Вывод
8
Пример 2
Ввод	
5 2
1 2
2 2
Вывод
5
Пример 3
Ввод	
1000 1
1 1
Вывод
715
Примечание к примеру 1:
Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия объявляет забастовки в дни 3, 8, 13, 18. Третья партия — в дни 9 и 17. Дни номер 6, 7, 13, 14 являются выходными. Таким образом, забастовки пройдут в дни 2, 3, 5, 8, 9, 11, 17, 18.]]></description>
    </test>
    <test id="51" subject="Предметы по выбору" testSetFolder="Predmetypovyboru">
      <description><![CDATA[Задача с семинара:
Студенты выбирают для себя предметы по выбору из списка. Выбрать нужно хотя бы один.
По очереди они вводят в консоль свою фамилию.
Программа отображает список предметов, затем студент вводит строку с названием предмета.
Если неверно, то надо повторить, окончание ввода - пустая строка.
Программа должна рассчитать:
 1. На какой предмет записалось больше всего студентов?
 2. Какие предметы остались не заняты? На какие предметы записался хотя бы один студент?
 3. Есть ли предметы, на которые записались все?
 4. Есть ли студенты с одинаковым набором предметов?
]]></description>
    </test>
  </homework>
  <homework id="52" name="Словари">
    <test id="53" subject="Номер появления слова" testSetFolder="numberOfWordInList">
      <description><![CDATA[Во входном потоке записан текст. Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
Ограничение времени	1 секунда
Ограничение памяти	64Mb
+Формат ввода+
Вводится текст.
+Формат вывода+
Выведите ответ на задачу.
*Пример 1*
+Ввод+
one two one tho three
+Вывод+
0 0 1 0 0 
*Пример 2*
+Ввод+
She sells sea shells on the sea shore;
The shells that she sells are sea shells I'm sure.
So if she sells sea shells on the sea shore,
I'm sure that the shells are sea shore shells.
+Вывод+
0 0 0 0 0 0 1 0 0 1 0 0 1 0 2 2 0 0 0 0 1 2 3 3 1 1 4 0 1 0 1 2 4 1 5 0 0 
*Пример 3*
+Ввод+
aba aba; aba @?"
+Вывод+
0 0 1 0]]></description>
    </test>
    <test id="54" subject="Частотный анализ" testSetFolder="frequencyAnalysis">
      <description><![CDATA[Дан текст (в файле input.txt). Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по убыванию их количества появления в тексте, а при одинаковой частоте появления — в лексикографическом порядке.
*Пример*
+Ввод+
oh you touch my tralala 
mmm my ding ding dong
+Вывод+
ding
my
dong
mmm
oh
touch
tralala
you]]></description>
    </test>
    <test id="55" subject="Выборы Государственной Думы" testSetFolder="parlamentElections">
      <description><![CDATA[Статья 83 закона “О выборах депутатов Государственной Думы Федерального Собрания Российской Федерации” в предыдущей редакции определяет следующий алгоритм пропорционального распределения мест в парламенте.
Необходимо распределить 450 мест между партиями, участвовавших в выборах. 
Сначала подсчитывается сумма голосов избирателей, поданных за каждую партию и подсчитывается сумма голосов, поданных за все партии. Эта сумма делится на 450, получается величина, называемая “первое избирательное частное” (смысл первого избирательного частного - это количество голосов избирателей, которое необходимо набрать для получения одного места в парламенте).
Далее каждая партия получает столько мест в парламенте, чему равна целая часть от деления числа голосов за данную партию на первое избирательное частное.
Если после первого раунда распределения мест сумма количества мест, отданных партиям, меньше 450, то оставшиеся места передаются по одному партиям, в порядке убывания дробной части частного от деления числа голосов за данную партию на первое избирательное частное. Если же для двух партий эти дробные части равны, то преимущество отдается той партии, которая получила большее число голосов.
+Формат ввода+
На вход программе подается список партий, участвовавших в выборах. Каждая строка входного файла содержит название партии (строка, возможно, содержащая пробелы), затем, через пробел, количество голосов, полученных данной партией – число, не превосходящее 108.
+Формат вывода+
Программа должна вывести названия всех партий и количество голосов в парламенте, полученных данной партией. Названия необходимо выводить в том же порядке, в котором они шли во входных данных.
В случае ввода некорректных данных программа должна вывести "ERROR!" и корректно завершить работу.
*Пример 1*
+Ввод+
Party One 100000
Party Two 200000
Party Three 400000
+Вывод+
Party One 64
Party Two 129
Party Three 257
*Пример 2*
+Ввод+
Party number one 100
Partytwo 100
+Вывод+
Party number one 225
Partytwo 225]]></description>
    </test>
    <test id="56" subject="Контрольная по ударениям" testSetFolder="accentQuiz">
      <description><![CDATA[Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение. Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку. Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество ошибок, которое в этом задании насчитает Вася.
Ограничение времени	1 секунда
Ограничение памяти	64Mb
+Формат ввода+
Вводится сначала число N — количество слов в словаре (0≤N≤20000). Далее идет N строк со словами из словаря. Каждое слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв. В каждом слове заглавная ровно одна буква — та, на которую попадает ударение. Слова в словаре расположены в алфавитном порядке. Если есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут в произвольном порядке. Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста, суммарным объемом не более 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним пробелом. Длина каждого слова не превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв (заглавными обозначены те буквы, над которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить ударения вовсе.
+Формат вывода+
Выведите количество ошибок в Петином тексте, которые найдет Вася.
*Пример 1*
+Ввод+
4
cAnnot
cannOt
fOund
pAge
thE pAge cAnnot be found
+Вывод+
2
*Пример 2*
+Ввод+
4
cAnnot
cannOt
fOund
pAge
The PAGE cannot be found
+Вывод+
4
*Примечания*
Примечания к примерам тестов
1. В слове cannot, согласно словарю возможно два варианта расстановки ударения. Эти варианты в словаре могут быть перечислены в любом порядке (т.е. как сначала cAnnot, а потом cannOt, так и наоборот). Две ошибки, совершенные Петей — это слова be (ударение вообще не поставлено) и fouNd (ударение поставлено неверно). Слово thE отсутствует в словаре, но поскольку в нем Петя поставил ровно одно ударение, признается верным. 2. Неверно расставлены ударения во всех словах, кроме The (оно отсутствует в словаре, в нем поставлено ровно одно ударение). В остальных словах либо ударные все буквы (в слове PAGE), либо не поставлено ни одного ударения.]]></description>
    </test>
    <test id="57" subject="Банковские счета" testSetFolder="bankAccounts">
      <description><![CDATA[Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:
* Пополнение счета клиента.
* Снятие денег со счета.
* Запрос остатка средств на счете.
* Перевод денег между счетами клиентов.
* Начисление процентов всем клиентам.
Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами (уникальная строка, не содержащая пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пололнения, снятия или перевода денег, ему заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим счетом. Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.
+Формат ввода+
Входной поток содержит последовательность операций. Возможны следующие операции: 
* DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет счета, то счет создается. 
* WITHDRAW name sum - снять сумму sum со счета клиента name. Если у клиента нет счета, то счет создается. 
* BALANCE name - узнать остаток средств на счету клиента name. 
* TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на счет клиента name2. Если у какого-либо клиента нет счета, то ему создается счет. 
* INCOME p - начислить всем клиентам, у которых открыты счета, процент суммы счета. Проценты начисляются только клиентам с положительным остатком на счету, если у клиента остаток отрицательный, то его счет не меняется. После начисления процентов сумма на счету остается целой, то есть начисляется только целое число денежных единиц. Дробная часть начисленных процентов отбрасывается.
+Формат вывода+
Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. Если же у клиента с запрашиваемым именем не открыт счет в банке, выведите ERROR.
В случае ввода некорректных данных программа должна вывести "Invalid Data!" и корректно завершить работу.
*Пример 1*
+Ввод+
DEPOSIT Ivanov 100
INCOME 5
BALANCE Ivanov
TRANSFER Ivanov Petrov 50
WITHDRAW Petrov 100
BALANCE Petrov
BALANCE Sidorov
+Вывод+
105
-50
ERROR
*Пример 2*
+Ввод+
BALANCE Ivanov
BALANCE Petrov
DEPOSIT Ivanov 100
BALANCE Ivanov
BALANCE Petrov
DEPOSIT Petrov 150
BALANCE Petrov
DEPOSIT Ivanov 10
DEPOSIT Petrov 15
BALANCE Ivanov
BALANCE Petrov
DEPOSIT Ivanov 46
BALANCE Ivanov
BALANCE Petrov
DEPOSIT Petrov 14
BALANCE Ivanov
BALANCE Petrov
+Вывод+
ERROR
ERROR
100
ERROR
150
110
165
156
165
156
179
+Пример 3+
+Ввод+
BALANCE a
BALANCE b
DEPOSIT a 100
BALANCE a
BALANCE b
WITHDRAW a 20
BALANCE a
BALANCE b
WITHDRAW b 78
BALANCE a
BALANCE b
WITHDRAW a 784
BALANCE a
BALANCE b
DEPOSIT b 849
BALANCE a
BALANCE b
+Вывод+
ERROR
ERROR
100
ERROR
80
ERROR
80
-78
-704
-78
-704
771]]></description>
    </test>
    <test id="58" subject="Подсчет уровней родства" testSetFolder="treeOfParents">
      <description><![CDATA[У каждого узла в генеалогическом древе, кроме его родоначальника, есть ровно один родитель. Каждом элементу дерева сопоставляется целое неотрицательное число, называемое высотой, т.е. "расстоянием" от родоначальника. У родоначальника высота равна 0, у любого другого элемента высота на 1 больше, чем у его родителя. Вам дано генеалогическое древо, определите _высоту_ всех его элементов.
Программа получает на вход число элементов в генеалогическом древе *N*. Далее следует *N-1* строка, задающие родителя для каждого элемента древа, кроме родоначальника. Каждая строка имеет вид _имя_потомка имя_родителя_.
*Формат вывода*
Программа должна вывести список всех элементов древа в +лексикографическом+ порядке. После вывода имени каждого элемента необходимо вывести его высоту.
*Пример*
+Ввод:+
9
Alexei Peter_I
Anna Peter_I
Elizabeth Peter_I
Peter_II Alexei
Peter_III Anna
Paul_I Peter_III
Alexander_I Paul_I
Nicholaus_I Paul_I
+Вывод:+
Alexander_I 4
Alexei 1
Anna 1
Elizabeth 1
Nicholaus_I 4
Paul_I 3
Peter_I 0
Peter_II 2
Peter_III 2]]></description>
    </test>
  </homework>
  <homework id="59" name="Функциональное программирование">
    <test id="60" subject="Количество различных чисел2" testSetFolder="FuncNumberOfVariousNumersInARow">
      <description/>
    </test>
    <test id="61" subject="Есть ли ноль?" testSetFolder="FuncIsThereAZero">
      <description><![CDATA[Ноль или не ноль
Проверьте, есть ли среди данных N чисел нули.
Вводится число N, а затем N чисел.
Выведите True, если среди введенных чисел есть хотя бы один нуль, или False в противном случае.
Программа должна содержать ровно одну инструкцию языка.
Пример:
Ввод	
3
4
19
14
Вывод
False
Примечание: используйте sys.stdin.read() для чтения потока данных, содержащих перевод строки.]]></description>
    </test>
    <test id="62" subject="Наименьший нечетный" testSetFolder="FuncLowestOddNumber">
      <description><![CDATA[Выведите значение наименьшего нечетного элемента списка, гарантируется, что хотя бы один нечётный элемент в списке есть.
Вводится список чисел. Все числа списка находятся на одной строке.
Программа должна содержать ровно одну инструкцию языка.]]></description>
    </test>
    <test id="63" subject="Произведение пятых степеней" testSetFolder="FuncFifthGradeMult">
      <description><![CDATA[(Решение задачи необходимо оформить в одну инструкцию языка)
На вход подаётся последовательность натуральных чисел длины . Посчитайте произведение пятых степеней чисел в последовательности.
Пример 1
Ввод	
1 1 1 2
Вывод
32
Пример 2
Ввод
2 1 1 2 2
Вывод
32768
Пример 3
Ввод	
10 100 1000 10000 2
Вывод
3200000000000000000000000000000000000000000000000000
*Примечания
Для решения задачи используйте функцию reduce из модуля functools*]]></description>
    </test>
    <test id="64" subject="Все перестановки заданной длины" testSetFolder="FuncAllRecombinations">
      <description><![CDATA[(Решение необходимо оформить в одну строку)
По данному числу N выведите все перестановки чисел от 1 до N в лексикографическом порядке.
Задано 1 число: N (0<N<10).
Необходимо вывести все перестановки чисел от 1 до N в лексикографическом порядке. Перестановки выводятся по одной в строке, числа в перестановке выводятся без пробелов.
Пример 1
Ввод
1
Вывод
1
Пример 2
Ввод	
2
Вывод
12
21
Пример 3
Ввод	
3
Вывод
123
132
213
231
312
321
Примечание: библиотека itertools вам поможет.]]></description>
    </test>
    <test id="65" subject="Ставки" testSetFolder="FuncBetsCocroaches">
      <description><![CDATA[Ограничение времени	1 секунда
Решение необходимо оформить в одну строку
Перед началом тараканьих бегов всем болельщикам было предложено сделать по две ставки на результаты бегов. Каждая ставка имеет вид "Таракан №A придет раньше, чем таракан №B". Организаторы бегов решили выяснить, могут ли тараканы прийти в таком порядке, чтобы у каждого болельщика сыграла ровно одна ставка из двух (то есть чтобы ровно одно из двух утверждений каждого болельщика оказалось верным). Считается, что никакие два таракана не могут прийти к финишу одновременно.
Формат ввода
В первой строке входных данных содержатся два разделенных пробелом натуральных числа: число K, не превосходящее 10, - количество тараканов и число N, не превосходящее 100, - количество болельщиков. Все тараканы пронумерованы числами от 1 до K. Каждая из следующих N строк содержит 4 натуральных числа A, B, C, D, не превосходящих K, разделенных пробелами. Они соответствуют ставкам болельщика "Таракан №A придет раньше, чем таракан №B" и "Таракан №C придет раньше, чем таракан №D".
Формат вывода
Если завершить бега так, чтобы у каждого из болельщиков сыграла ровно одна из двух ставок, можно, то следует вывести номера тараканов в том порядке, в котором они окажутся в итоговой таблице результатов (сначала номер таракана, пришедшего первым, затем номер таракана, пришедшего вторым и т. д.) в одну строку через пробел. Если таких вариантов несколько, выведите любой из них. Если требуемого результата добиться нельзя, выведите одно число 0.
Пример 1
Ввод	
3 2
2 1 2 3
1 2 3 2
Вывод
3 2 1
Пример 2
Ввод	
3 4
1 2 1 3
1 2 3 1
1 2 2 3
1 2 3 2
Вывод
0]]></description>
    </test>
    <test id="66" subject="Реализация XOR" testSetFolder="FuncXoR">
      <description><![CDATA[Булева функция XOR (сложение по модулю два) задаётся следующей таблицей истинности:
_xor(0, 0) = 0
xor(0, 1) = 1
xor(1, 0) = 1
xor(1, 1) = 0_
На вход подаются две последовательности (a1, …, an) и (b1, …, bn) из 0 и 1.
Необходимо получить последовательность из (c1, …, cn), где каждая ci = xor(ai, bi).
Формат ввода
На вход подаются две строки из 0 и 1, разделённых пробелами.
Первая строка — это последовательность (a1, …, an).
Вторая строка — это последовательность (b1, …, bn).
Формат вывода
Выведите последовательность (c1, …, cn), разделяя каждый элемент пробелом
*+Пример+*
Ввод	
0 0 1 1
0 1 0 1
Вывод
0 1 1 0
Примечание:
Функция zip вам в помощь.]]></description>
    </test>
  </homework>
  <homework id="67" name="Классы python">
    <test id="68" subject="Класс Матрица" testSetFolder="classMatrix">
      <description><![CDATA[Реализуйте класс Matrix. 
*Он должен содержать:*
1. Конструктор от списка списков. Гарантируется, что списки состоят из чисел, не пусты и все имеют одинаковый размер. Конструктор должен копировать содержимое списка списков, т.е. при изменении списков, от которых была сконструирована матрица, содержимое матрицы изменяться не должно.
2. Метод __str__ переводящий матрицу в строку. При этом элементы внутри одной строки должны быть разделены знаками табуляции, а строки — переносами строк. При этом после каждой строки не должно быть символа табуляции и в конце не должно быть переноса строки.
3. Метод size без аргументов, возвращающий кортеж вида (число строк, число столбцов)
4. __add__ принимающий вторую матрицу того же размера и возвращающий сумму матриц
5. __mul__ принимающий число типа int или float и возвращающий матрицу, умноженную на скаляр
6. __rmul__ делающий то же самое, что и __mul__. Этот метод будет вызван в том случае, аргумент находится справа. Можно написать __rmul__ = __mul__
Например:
В этом случае вызовется __mul__: Matrix([[0, 1], [1, 0]) * 10
В этом случае вызовется __rmul__ (так как у int не определен __mul__ для матрицы справа): 10 * Matrix([[0, 1], [1, 0])
Разумеется, данные методы не должны менять содержимое матрицы.
На проверку вы должны сдать файл, содержащий описание класса и примеры вызова каждой из функций в "__main__". 
*NB!*
При проверке будет использован собственный "__main__", в котором импортирована матрица следующим образом:
<pre>
from matrix import Matrix
</pre>]]></description>
    </test>
    <test id="69" subject="Наследование" testSetFolder="classHierarchy">
      <description><![CDATA[К программе в предыдущей задаче добавьте класс SquareMatrix – наследник Matrix с операцией возведения в степень __pow__, принимающей натуральную (с нулём) степень, в которую нужно возвести матрицу.
]]></description>
    </test>
  </homework>
  <homework id="70" name="Регулярные выражения">
    <test id="71" subject="Список доменов" testSetFolder="regDomains">
      <description><![CDATA[Необходимо с помощью регулярных выражений вернуть список доменов 1 и 2 уровня(если есть) из списка адресов электронной почты, заданного строкой через ","
Пример:
*Ввод:*
"myMail@gmail.com, company@xerox.co.uk"
*Вывод:*
com
gmail.com
uk
co.uk]]></description>
    </test>
    <test id="72" subject="Поиск повторов с заменой" testSetFolder="regFindReplaceRepeated">
      <description><![CDATA[С помощью регулярных выражений найдите в строке дважды подряд повторяющиеся слова.
Удалите эти повторы, распечатайте строку без повторов.
Пример:
Ввод
Send me a letter letter.
Вывод
Send me a letter.
Ввод
What a a nice girl girl.
Вывод
What a nice girl.
]]></description>
    </test>
    <test id="73" subject="Поиск повторов" testSetFolder="regFindRepeated">
      <description><![CDATA[С помощью регулярных выражений найдите в строке дважды подряд повторяющиеся слова.
Распечатайте их.
Пример:
Ввод
Send me a letter letter.
Вывод
letter
Ввод
What a a nice girl girl.
Вывод
a
girl
]]></description>
    </test>
    <test id="74" subject="Поиск употреблений" testSetFolder="regFindAllFormsOfTime">
      <description><![CDATA[С помощью регулярных выражений найдите все употребления стоящего отдельно слова "время" в тексте.
Нужно учесть все варианты склонений этого слова. Если оно содержится внутри другого слова, соответствия не должно находиться.
*Пример 1*
Ввод:
Времени ни на что не хватает
Вывод:
Времени
Ввод:
Да временщик он!
Вывод:
No
Ввод:
Делу - время, потехе - час.
Вывод:
время
]]></description>
    </test>
    <test id="75" subject="Телефонные номера-2" testSetFolder="regPhoneNumbers">
      <description><![CDATA[На вход программе подаются строки, содержащие телефонные номера. Выведите "Correct", если номер в строке проходит по формату, затем в этой же строке выведите преобразованный номер в международном формате, например "+79035553399"
Если номера нет или он не в правильном формате, выведите "No"
Правильными считаются номера, в которых присутствует 10 цифр(возможно, с разделителями), и, опционально, 8, +7 или 7.
Пример:
*Ввод:*
Вася, позвони Пете, его номер 8903 1234567. 
Петя, привет, нет, 903 500 01 11 - не его номер.:(
А какой?
Вроде  123 в конце.
Не знаю, попробуй 79991112233
*Вывод:*
Correct:+79031234567
Correct:+79035000111
No
No
Correct:+79991112233
]]></description>
    </test>
    <test id="76" subject="Перевод шкал" testSetFolder="regChangeScales">
      <description><![CDATA[Создайте программу для поиска в строке градусов по шкале Фаренгейта и замены их значениями по шкале Цельсия.
В строке температура в фаренгейтах представляет из себя число (не обязательно целое), заканчивающееся буквой F.
C = (F - 32) * 5 / 9
Округление производите до второго знака.
Пример:
Ввод:
He was sick. His temperature was about 100F.
Вывод:
He was sick. His temperature was about 37.78С.
Ввод:
He was sick. His temperature was about 100.1 F.
Вывод:
He was sick. His temperature was about 37.83С.]]></description>
    </test>
    <test id="77" subject="Последнее слово" testSetFolder="regLastWord">
      <description><![CDATA[Необходимо с помощью регулярного выражения вывести последнее слова из введенных предложений.
На вход программа получает текст, выведите по одному нужному слову в отдельной строке.
Пример:
*Ввод:*
Ночь. Улица. Фонарь. Аптека. Бессмысленный и тусклый свет. Живи еще хоть четверть века, всё будет так, исхода нет.
*Вывод:*
Ночь
Улица
Фонарь
Аптека
свет
нет]]></description>
    </test>
    <test id="78" subject="Поиск настроек игры" testSetFolder="regGameSettings">
      <description><![CDATA[Игра "SuperGame" имеет большое количество файлов в своем каталоге установки. Этот каталог передается на вход Вашему решению первым параметром, например:
_python mySolution.py C:\programs\supergame\_
Нужно с помощью регулярных выражений найти в этом каталоге все файлы, не являющиеся исполняемыми и распечатать их полные пути. Исполняемыми для простоты принимаем файлы, имеющие расширение (.exe, .com, .js).
]]></description>
    </test>
  </homework>
  <homework id="79" name="Контрольная работа номер 1">
    <test id="80" subject="Обращение фрагмента" testSetFolder="fragmentReverse">
      <description><![CDATA[Дана строка, в которой буква h встречается как минимум два раза. 
Разверните последовательность символов, заключенную между первым и последним появлением буквы h, в противоположном порядке.
В качестве ответа нужно выводить одну строковую переменную.
+Формат ввода:+
Вводится строка.
+Формат вывода:+
Выведите ответ на задачу.
*Пример* 
+Ввод:+
In the hole in the ground there lived a hobbit
+Вывод:+
In th a devil ereht dnuorg eht ni eloh ehobbit
*Примечания:*
1. Решения, в которых используются циклы, будут оценены в 0 баллов.
2. Решения, в которых не формируется измененная строка (а только выводится ответ по частям) будут оценены в 0 баллов.
]]></description>
    </test>
    <test id="81" subject="Сумма десятичных цифр" testSetFolder="sumOfDecNumbers">
      <description><![CDATA[Вычислите сумму цифр целого числа, заданного в десятичной системе счисления.
В решениях нельзя пользоваться строковыми методами.
+Формат ввода+
Задано единственное число N.
+Формат вывода+
Необходимо вывести сумму цифр числа N.
В случае ввода некорректных данных, программа должна вывести сообщение "ERROR" и корректно завершить работу.
*Пример 1* 
+Ввод+	
15
+Вывод+
6
*Пример 2* 
+Ввод+	
-3.6
+Вывод+
ERROR
*Пример 3* 
+Ввод+	
-15
+Вывод+
6]]></description>
    </test>
    <test id="82" subject="Расписание звонков" testSetFolder="alarmsTimeTable">
      <description><![CDATA[В некоторой школе занятия начинаются в 9:00. Продолжительность урока — 45 минут, после 1-го, 3-го, 5-го и т.д. уроков перемена 5 минут, а после 2-го, 4-го, 6-го и т.д. — 15 минут.
В этой задаче можно пользоваться только арифметическими операциями (нельзя использовать if, while и т.д. и т.п.)
Дан номер урока (число от 1 до 10). Определите, когда заканчивается указанный урок.
Выведите два целых числа: время окончания урока в часах и минутах.
Пример: 
Ввод	
3
Вывод
11 35]]></description>
    </test>
    <test id="83" subject="Парты" testSetFolder="buyingNewDesks">
      <description><![CDATA[В университете решили оборудовать три кабинета новыми столами. За каждым столом может сидеть два студента. Известно масимальное количество студентов в каждом из трех кабинетов. Выведите наименьшее число столов, которое нужно приобрести для них.
В этой задаче можно пользоваться только арифметическими операциями (нельзя использовать if, while и т.д. и т.п.)
*Формат ввода*
Программа получает на вход три натуральных числа: максимальное количество студентов в каждом из трех кабинетов (числа не превышают 1000).
*Формат вывода*
Выведите ответ на задачу: минимальное необходимое число столов.
В случае ввода некорректных данных, программа должна вывести сообщение "ERROR" и корректно завершить работу.
*Пример*
+Ввод+	
20
21
22
+Вывод+
32]]></description>
    </test>
    <test id="84" subject="Коньки" testSetFolder="puttingOnSkates">
      <description><![CDATA[В прокате есть несколько размеров коньков. На каток пришло несколько мальчиков и девочек. Вам необходимо определить, какое количество посетителей прокат коньков сможет обслужить. 
В первой строке ввода пречислены размеры коньков(натуральные числа), доступные в прокате. Во второй строке - запрашиваемые размеры коньков. Необходимо вывести единственное число - количество выданных коньков.
	  +Пример 1+:
	  Ввод:
	  41 40 39 42
	  42 41 42
	  Вывод:
	  2
	  +Пример 2+:
	  Ввод:
	  5 1 2 3 4
          5 5 5 5 5
	  Вывод:
	  1]]>
	  </description>
    </test>
    <test id="85" subject="Симметричная последовательность" testSetFolder="simmetricSequence"/>
    <test id="86" subject="Распределение фигуристов по правилам ISU" testSetFolder="kr1SportsmenIsu">
      <description><![CDATA[Задача о распределении фигуристов по разминкам на соревнованиях согласно правилам ISU.
На вход подается одно число - количество спортсменов-фигуристов, участников соревнований, большее 10.
Нужно распределить спортсменов по разминкам так, чтобы в одной разминке было не более 6 человек, а разминки с б*о*льшим количеством участников имели б*о*льший порядковый номер.
Количество разминок должно быть минимальным, количество участников во всех разминках не должно отличаться более, чем на единицу.
*Пример 1*
+Ввод+
11
+Вывод+
5+6
*Пример 2*
+Ввод+
14
+Вывод+
4+5+5
*Пример 3*
+Ввод+
18
+Вывод+
6+6+6
В случае некорректных входных данных выведите "ERROR".]]></description>
    </test>
    <test id="87" subject="Номер числа Фибоначчи" testSetFolder="kr1Fibbonachi">
      <description><![CDATA[Последовательность Фибоначчи определяется так:
!https://i.ibb.co/TtVFQWy/fib.png!
Дано натуральное число *number*. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n, что
Fn=*number*
Если *number* не является числом Фибоначчи, выведите число -1.
Если введены некорректные данные, программа должна вывести сообщение "ERROR" и корректно завершить работу.
*Формат ввода*
Вводится натуральное число *number*.
*Формат вывода*
Выведите ответ на задачу.
*Пример 1*
+Ввод+	
8
+Вывод+
6
*Пример 2*
+Ввод+	
10
+Вывод+
-1
*Пример 3*
+Ввод+	
13
+Вывод+
7]]></description>
    </test>
    <test id="88" subject="Побочные четные" testSetFolder="oddDiagonalEvenNumbers">
      <description><![CDATA[Для матрицы m*m вам нужно найти четные по значению элементы побочной диагонали.
*Формат ввода:*
Сначала вводится размер матрицы, затем построчно сама матрица.
*Формат вывода:*
Если элементов нет или в случае какой-либо ошибки ввода распечатайте -1.
Если введены некорректные данные, программа должна вывести сообщение "ERROR" и корректно завершить работу.
*Пример 1:*
+Ввод+
2
1 2
2 4
+Вывод+
2
2
*Пример 2:*
+Ввод+
2
1 3
3 5
+Вывод+
-1
*Пример 3:*
+Ввод+
1
0
+Вывод+
0]]></description>
    </test>
    <test id="259" subject="Вычисление производных" testSetFolder="countDeriviatives">
      <description><![CDATA[Вам дана функция-многочлен в виде массива коэффициентов. Необходимо рассчитать ее производную порядка n. Коэффициенты многочлена вводится через пробел, затем идет единственное число – производную какого порядка необходимо рассчитать.
+Пример:+
Ввод:
1 3 -2 17
1 
Вывод:
3 6 -2
Т.е. вычисляем первую производную от функции: y(x) = x*x*x + 3*x*x – 2*x + 17, 
она равна y’(x) = 3*x*x + 6*x - 2]]></description>
    </test>
  </homework>
  <homework id="89" name="Контрольная работа номер 2">
    <test id="90" subject="Автомобильные номера" testSetFolder="automobileNumbers">
      <description><![CDATA[Неизвестный водитель совершил ДТП и скрылся с места происшествия. Полиция опрашивает свидетелей. Каждый из них говорит, что запомнил какие-то буквы и цифры номера. Но при этом свидетели не помнят порядок этих цифр и букв. Полиция хочет проверить несколько подозреваемых автомобилей. Будем говорить, что номер согласуется с показанием свидетеля, если все символы, которые назвал свидетель, присутствуют в этом номере (не важно, сколько раз).
+Формат ввода+
Сначала задано число  - количество свидетелей. Далее идет M строк, каждая из которых описывает показания очередного свидетеля. Эти строки непустые и состоят из не более чем 20 символов. Каждый символ в строке - либо цифра, либо заглавная латинская буква, причём символы могут повторяться. 
Затем идёт число  - количество номеров. Следующие строки представляют из себя номера подозреваемых машин и имеют такой же формат, как и показания свидетелей.
+Формат вывода+
Выведите номера автомобилей, согласующиеся с показаниями максимального количества свидетелей. Если таких номеров несколько, то выведите их в том же порядке, в котором они были заданы на входе.
*Пример 1*
+Ввод+	
3
ABC
A37
BCDA
2
A317BD
B137AC
+Вывод+
B137AC
*Пример 2*
+Ввод+	
2
1ABC
3A4B
3
A143BC
C143AB
AAABC1
+Вывод+
A143BC
C143AB
]]></description>
    </test>
    <test id="91" subject="Номер появления слова. Версия 2" testSetFolder="wordAppearences">
      <description><![CDATA[На вход подается текст в кодировке UTF-8. *Словом* считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки.
*Числом* называется слово, состоящее только из цифр.
+Требуется+
1. Вывести все числа в тексте.
2. Вывести, сколько среди них различных.
2. Для каждого числа из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
*Пример 1*
+Ввод+	
one two 23 one 23 tho three
+Вывод+
23 23
1
23 - 0
23 - 1
*Пример 2*
+Ввод+	
one two three
+Вывод+
(пустая строка)
0
(пустая строка)]]></description>
    </test>
    <test id="92" subject="Замена" testSetFolder="kr21HtmlExchange">
      <description><![CDATA[<pre>
В некоторых системах текст, обрамленный в "*", должен отображаться полужирным.
Требуется написать метод, который для входной строки заменит её участки, обрамленные в "*" на их html-представление.
Например:
This is *important*! -> This is <b>important</b>!
При этом, если в жирном тексте нужно отобразить звездочку, то ее надо экранировать, поставив перед ней \.
+Пример 1:+
Ввод: 
This is *important*!
Вывод:
This is <b>important</b>
+Пример 2:+
Ввод: 
2*3
Вывод:
2*3
+Пример 3:+
Ввод: 
*2\*3*
Вывод:
<b>2*3</b>
+Пример 4:+
Ввод: 
*This is *important*!*
Вывод:
<b>This is </b>important<b>!</b>
</pre>]]></description>
    </test>
    <test id="93" subject="Вычисление количества цифр" testSetFolder="calculateSimpleDigits">
      <description><![CDATA[Дана последовательность чисел, состоящая только из чисел 1, ..., 9. Последовательность завершается числом 0. Каждое число записано в отдельной строке.
Подсчитайте, сколько раз в этой последовательности встречаются значения 1, 2, ..., 9. Сохранять всю последовательность введенных чисел в списке нельзя.
Программа должна вывести ровно 9 чисел: количество единиц, двоек, ..., девяток в данной последовательности.
Пример 1
Ввод	
4
9
3
4
2
4
9
4
3
8
0
Вывод
0 1 2 4 0 0 0 1 2 
Пример 2
Ввод	
1
0
Вывод
1 0 0 0 0 0 0 0 0]]></description>
    </test>
    <test id="94" subject="Чемпионат по метанию коровьих лепешек" testSetFolder="cowChampionship">
      <description><![CDATA[Ежегодный турнир "Веселый коровяк" - по метанию коровьих лепешек на дальность - прошел 8-9 июля в селе Крылово-Осинского района Пермского края.
Участники соревнований кидают "снаряд" - спрессованный навоз, выбирая его из заранее заготовленной кучи. Желающих поупражняться в силе броска традиционно очень много. Каждую лепешку, которую метнули участники "Веселого коровяка", внимательно осматривали судьи в костюмах коров и тщательно замеряли расстояние.
Соревнования по метанию коровьих лепешек проводятся в Пермском крае с 2009 года.
!http://n1s2.starhit.ru/e3/67/dc/e367dc47fcb9de768e3a077d3b5ed7a2/1000x667_0_05afbbbe6c3a8045d55a949cd4276812@2316x1544_0xc0a8399a_13469740861502277752.jpeg!
К сожалению, после чемпионата потерялись записи с фамилиями участников, остались только записи о длине броска в том порядке, в котором их совершали участники.
Тракторист Василий помнит три факта:
1) Число метров, на которое он метнул лепешку, оканчивалось на 5.
2) Один из победителей чемпионата метал лепешку до Василия.
3) Участник, метавший лепешку сразу после Василия, метнул ее на меньшее количество метров
Будем считать, что участник соревнования занял k-е место, если ровно (k − 1) участников чемпионата метнули лепешку строго дальше, чем он.
*Какое максимально высокое место мог занять Василий?*
+Формат ввода+
Первая строка входного файла содержит целое число n — количество участников чемпионата по метанию лепешек (3 ≤ n ≤ 105).
Вторая строка входного файла содержит n положительных целых чисел, каждое из которых не превышает 1000, — дальность броска участников чемпионата, приведенные в том порядке, в котором происходило метание.
+Формат вывода+
Выведите самое высокое место, которое мог занять тракторист Василий. Если не существует ни одного участника чемпионата, который удовлетворяет, описанным выше условиям, выведите число 0.
В случае некорректных входных данных выведите "ERROR".
*Пример 1*
+Ввод+	
7
10 20 15 10 30 5 1
+Вывод+
6
*Пример 2*
+Ввод+	
3
15 15 10
+Вывод+
1]]></description>
    </test>
    <test id="95" subject="Жизнь в квадрате" testSetFolder="newLifeInASquare">
      <description><![CDATA[В некоторых клетках квадрата N x N живут микроорганизмы (не более одного в одной клетке). Каждую секунду происходит следующее:
– все микроорганизмы, у которых менее 2-х соседей, умирают от скуки (соседями называются микроорганизмы, живущие в клетках, имеющих общую сторону или вершину);
– все микроорганизмы, у которых более 3-х соседей, умирают от перенаселенности;
– в клетках, у которых ровно 2 соседа ничего не меняется;
– на всех пустых клетках, у которых ровно в трех соседних клетках жили микроорганизмы, появляются новые микроорганизмы.
Все изменения происходят одновременно, то есть для каждой клетки сначала выясняется ее судьба, а затем происходят изменения сразу во всех клетках. Требуется по данной конфигурации определить, во что она превратится через T секунд.
+Формат ввода+
В первой строке вводятся два натуральных числа – N (1 ≤ N ≤ 10) и T (1 ≤ T ≤ 100).
Далее записано N строчек по N чисел, описывающих начальную конфигурацию (0 – пустая клетка, 1 – микроорганизм). Числа в строках разделены пробелами.
+Формат вывода+
Требуется вывести N строк по N чисел – описание конфигурации через T секунд (в том же формате, как и во входных данных).
В случае некорректных входных данных выведите "ERROR".
*Пример 1*
+Ввод+	
3 1
1 0 1
1 0 1
1 0 1
+Вывод+
0 0 0 
1 0 1 
0 0 0 
*Пример 2*
+Ввод+	
2 2
1 1
1 1
+Вывод+
1 1 
1 1 
*Пример 3*
+Ввод+
2 100
1 0
0 0
+Вывод+
0 0 
0 0 
]]></description>
    </test>
    <test id="96" subject="Результаты голосования" testSetFolder="votes7persent">
      <description><![CDATA[В первой строке программе подается слово "PARTIES:". Далее идет список партий, участвующих в выборах.
Затем идет строка, содержащая слово "VOTES:". За ним идут названия партий, за которые проголосовали избиратели, по одному названию в строке. Названия могут быть +только+ строками из первого списка, если попалась что-либо еще в строке бюллетень считается недействительным, голос игнорируется.
Выведите список всех партий, участвовавших в выборах, отсортировав его в порядке убывания количества голосов избирателей, а при равном количестве голосов - в лексикографическом порядке.
*Пример 1*
+Ввод+	
PARTIES:
Party one
Party two
Party three
VOTES:
Party one
Party two
Party three
Party two
Party three
+Вывод+
Party three
Party two
Party one
Пример 2
Ввод	
PARTIES:
Party one
Party two
Party three
Party four
Party five
Party six
Party seven
Party eight
Party nine
Party ten
VOTES:
Party three
Party five
Party seven
Party ten
Party four
Party eight
Party one
Party two
Party six
Party nine
Вывод:
Party eight
Party five
Party four
Party nine
Party one
Party seven
Party six
Party ten
Party three
Party two]]></description>
    </test>
    <test id="97" subject="Сумма произведений соседних чисел" testSetFolder="sumOfNeibors">
      <description><![CDATA[По данному натуральному n≥2 вычислите сумму 1×2+2×3+...+(n-1)×n. Ответ выведите в виде вычисленного выражение и его значения *в точности*, как показано в примере.
+Формат ввода+
Вводится натуральное число.
+Формат вывода+
Выведите ответ на задачу.
*Пример 1*
+Ввод+	
4
+Вывод+
1*2+2*3+3*4=20
*Пример 2*
+Ввод+	
2
+Вывод+
1*2=2
*Пример 3*
+Ввод+	
3
+Вывод+
1*2+2*3=8
В случае некорректных входных данных выведите "ERROR".]]></description>
    </test>
    <test id="98" subject="Количество максимальных элементов последовательности" testSetFolder="kr12ResurciveList"/>
  </homework>
  <homework id="99" name="Контрольная работа regexp timedate">
    <test id="100" subject="Замена" testSetFolder="kr21HtmlExchange">
      <description><![CDATA[<pre>
В некоторых системах текст, обрамленный в "*", должен отображаться полужирным.
Требуется написать метод, который для входной строки заменит её участки, обрамленные в "*" на их html-представление.
Например:
This is *important*! -> This is <b>important</b>!
При этом, если в жирном тексте нужно отобразить звездочку, то ее надо экранировать, поставив перед ней \.
+Пример 1:+
Ввод: 
This is *important*!
Вывод:
This is <b>important</b>
+Пример 2:+
Ввод: 
2*3
Вывод:
2*3
+Пример 3:+
Ввод: 
*2\*3*
Вывод:
<b>2*3</b>
+Пример 4:+
Ввод: 
*This is *important*!*
Вывод:
<b>This is </b>important<b>!</b>
</pre>]]></description>
    </test>
    <test id="101" subject="Правильные даты" testSetFolder="kr21Dates"/>
    <test id="102" subject="Все оттенки серого(max 5)" testSetFolder="kr21ShadesOfGrey">
      <description><![CDATA[Задача: Выбрать отенки серого в разных цветовых системах.
Почитать про цвета можно  по этой ссылке http://htmlbook.ru/css/value/color. 
Проверить себя можно создав простую html-страницу c прямоугольником или фоном вводимого цвета.
Требуется написать функцию, которая для входящей строки будет возвращать True - если это серый цвет и False в противоположном случае.
Примеры: 
#FFF  —  False (т.к белый, а не серый)
#000 —  False (т.к чёрный, а не серый) 
rgb(2.5, 2.5,2.5)  —  True
rgb(2, 4, 7)  —  False
hsl(0,0%,75%) — True
#F3d3aa  —  False
На вход будет подана одна строка - в которой закодирован цвет в одном из допустимых вариантов.
На выходе ожидается одна строка "True" или "False".
Вряд ли Ваша программа пройдет все тесты. Задача будет оцениваться по количеству пройденных тестов.]]></description>
    </test>
    <test id="103" subject="Замена2" testSetFolder="kr21itallic">
      <description/>
    </test>
    <test id="104" subject="Сколько до лета" testSetFolder="kr21daysBetweenDates">
      <description><![CDATA[Вычислить количество дней между датами. На вход поступает 2 даты в формате mm-dd-yyyy, необходимо вывести сколько дней до второй даты, или -1 если вторая дата раньше первой.
Пример 1:
Ввод:
12-30-2020
12-31-2020
Вывод:
1
Пример 2:
Ввод:
12-30-2020
1-1-2021
Вывод:
2
Пример 3:
Ввод:
12-30-2020
12-21-2020
Вывод:
-1]]></description>
    </test>
    <test id="9284" subject="Сумма самых дальних элементов" testSetFolder="classTreeSumOfDeepest">
      <description><![CDATA[Вам дано бинарное дерево, представленное классом:
<pre>
class TreeNode(object):
     def init(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
</pre>
Вам нужно c помощью этого класса написать функцию, которая вычисляет сумму элементов самого дальнего от корня уровня.
Пример сигнатуры функции:
<pre>
from TreeNode import TreeNode
def sumDeepestLeafs(root):
    return 0
</pre>
Пример 1:
!https://i.ibb.co/wSKLqHq/1483-ex1.png!
Результат: 15
На максимальном удалении от корня находятся "листья" "7" и "8".
Пример 2:
!https://i.ibb.co/gWwy1H4/complete-binary-tree-2.png!
Результат:  16
Вам нужно сдавать функцию sumDeepestLeafs, которая импортирует TreeNode. Другие функции - по желанию.]]></description>
    </test>
  </homework>
  <homework id="105" name="Контрольная работа xml http">
    <test id="106" subject="Сколько стоит рубль" testSetFolder="kr22RublPrice">
      <description><![CDATA[С помощью курсов центробанка, доступных на странице http://www.cbr.ru/scripts/XML_daily.asp
Переведите 1 рубль в казахстанские тенге по курсу на 20.04.2022.
Обязательно использование методов работы с деревом xml.
Распечатайте результат в консоль (округлить нужно до копеек, по правилам математики).
Для определения курса на конкретную дату нужно использовать параметр запроса с именем "date_req" и значением даты в формате dd.mm.yyyy
Формат вывода:
1 Ruble is worth <количество> <код_валюты>
"количество" Вам необходимо рассчитать.
"код_валюты" - получить из xml файла]]></description>
    </test>
    <test id="107" subject="Памятные года" testSetFolder="kr22Dates">
      <description><![CDATA[C помощью Selenium найти все текстовые поля на странице:
https://24smi.org/celebrity/3555-petr-i.html
Затем с помощью регулярных выражений выбрать и распечатать все упоминания о годах, отсортированные по возрастанию по одному году в строке, например,
1700
1701
1702
1773
]]></description>
    </test>
    <test id="108" subject="Площадь участков земли" testSetFolder="kr22Triangles">
      <description><![CDATA[В некоторой стране для личных наделов фермеров используются участски треугольной формы. Для простоты один из углов треугольника должен быть прямым, а общая площадь должна равняться 120.
Предложите свой вариант длин двух коротких сторон, отправив POST запрос на страницу http://textanalysis.ru/3/sides.php
Стороны должны иметь название переменных "a" и "b" как принято у математиков.
Распечатайте сообщение об успешном решении задачи, присланное сервером. (Само сообщение - содержимое тега <h3>)]]></description>
    </test>
  </homework>
  <homework id="109" name="Зачет семестр 1">
    <test id="110" subject="Soundex" testSetFolder="soundex">
      <description><![CDATA[Известный алгоритм Soundex (https://ru.wikipedia.org/wiki/Soundex) определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.
Требуется реализовать этот алгоритм. Он работает так:
Первая буква слова сохраняется.
В остальной части слова:
буквы, обозначающие, как правило, гласные звуки: a, e, h, i, o, u, w и y — отбрасываются;
оставшиеся буквы (согласные) заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
1: b, f, p, v 
2: c, g, j, k, q, s, x, z 
3: d, t 
4: l
5: m, n 
6: r
Любая последовательность одинаковых цифр сокращается до одной такой цифры.
Итоговая строка обрезается до первых четырёх символов. Если длина строки меньше требуемой, недостающие символы заменяются знаком 0.
Примеры: 
аmmonium → ammnm → a5555 → a5 → a500 
implementation → implmnttn → i51455335 → i514535 → i514
Формат ввода
На вход подаётся одно непустое слово, записанное строчными латинскими буквами. Длина слова не превосходит 20 символов.
Выведите полученный код.]]></description>
    </test>
    <test id="111" subject="Светофор" testSetFolder="trafficlights">
      <description><![CDATA[Вася подошел к перекрестку и увидел, что на светофоре в этот момент загорелся красный свет. Вася залюбовался тем, как четко переключаются сигналы светофора:
красный – желтый – зеленый – желтый – красный – желтый – зеленый - …
Когда в очередной раз загорелся зеленый свет, Вася решил-таки перейти дорогу. К этому моменту зеленый свет зажегся в i-ый раз. Напишите программу, которая определит, сколько раз за это время загорался красный свет (считая и тот момент, когда Вася только подошел к перекрестку) и сколько раз — желтый.
Формат ввода
Задано одно число i, задающее, в какой раз загорелся зеленый свет (1≤i≤100).
Формат вывода
Выведите два числа. Первое — сколько раз загорался красный свет, второе — сколько раз загорался желтый.
Пример 1
Ввод	
2
Вывод
2 3]]></description>
    </test>
    <test id="112" subject="Предметный указатель" testSetFolder="indexingABook">
      <description><![CDATA[Профессор написал научную книгу и составил для неё предметный указатель. Это список ключевых слов, для каждого из которых указана страница, на которой это слово встречается. Теперь профессор хочет для каждой страницы выписать в алфавитном порядке все ключевые слова, которые на эту страницу попали (если такие вообще есть). Помогите профессору решить эту задачу.
Формат ввода
Даны n строк. В каждой строке сначала записано ключевое слово. Затем идёт натуральное число, не превосходящее 1000, — номер страницы. Ключевые слова состоят из латинских букв, не бывают пустым и по длине не превосходят 16 символов. Слова в списке, конечно, могут повторяться.
Формат вывода
Выпишите в порядке возрастания все страницы, на которых присутствуют ключевые слова. После каждого номера страницы через пробел выпишите в алфавитном порядке сами эти слова. Если на какой-то странице слово встретилось несколько раз, то повторять его не нужно. Завершающего пробела в конце строк быть не должно.
*Пример*
Ввод	
derivative 10
function 2
function 10
function 10
limit 7
Вывод
2 function
7 limit
10 derivative function]]></description>
    </test>
    <test id="113" subject="Минимум на отрезке" testSetFolder="minimumInTheFrame">
      <description><![CDATA[Дана последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k, то есть сначала в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.
Формат ввода
В первой строке входных данных содержатся два натуральных числа n и k (n ≤  150000, k ≤ 10000, k ≤  n) – длины последовательности и «окна», соответственно. На следующей строке находятся n чисел – сама последовательность.
Формат вывода
Выходые данные должны содержать n - k + 1 строк – минимумы для каждого положения «окна».
*Пример*
Ввод	
7 3
1 3 2 4 5 3 1
Вывод
1
2
2
3
1
Примечания
Обратите внимание, что решение с непосредственным подсчётом минимума для каждого положения окна будет оценено не на максимум баллов.]]></description>
    </test>
    <test id="114" subject="Правильная скобочная последовательность" testSetFolder="checkIfBracesAreCorrect">
      <description><![CDATA[Для введенной строки символов определить, правильно ли расставлены скобки.
Учитывать нужно только () и {}. 
В строке встречаются буквы, цифры, пробелы и скобки, например
(ааа ааа), (а{а}) - правильные последовательности
Требуется вывести 1, если в строке есть хотя бы одна ошибка, 0 - если ошибок нет.]]></description>
    </test>
    <test id="115" subject="Лавочки в ТЦ Кунцево Плаза" testSetFolder="z1Lavochki">
      <description><![CDATA[В атриуме в ТЦ Кунцево Плаза урбанисты установили модные гранитные лавочки (на которых холодно сидеть зимой и часто жарко летом). Лавочка устроена следующим образом: несколько одинаковых кубических гранитных блоков ставятся в ряд, а на них кладется гранитная плита.
При этом блоки располагаются так, чтобы +плита не падала+: для этого достаточно, чтобы и слева, и справа от центра плиты был *хотя бы один* гранитный блок или его часть (в частности, если центр плиты приходится на середину какого-нибудь блока, то и слева, и справа от центра плиты находится часть блока, и плита не падает).
В сентябре, пока еще было можно заниматься очно, в МАИ было много студентов на молодежной (но это только пока не произошли отчисления по результатам сессии) и им часто не хватает стульев в фудкорте. Студенты обнаружили, что блоки можно использовать в качестве сиденья. Можно по одному вытаскивать блоки, находящиеся *с краю* (как слева, так и справа). Они хотят вытащить из-под лавочки как можно больше блоков так, чтобы она при этом не упала (передвигать оставшиеся блоки нельзя). Определите, какие блоки они должны *+оставить+*.
Формат ввода
В первой строке входных данных содержатся два числа: L - длина лавочки и K - количество гранитных блоков-ножек. Оба числа натуральные и не превышают 10 000.
Во второй строке следуют K различных целых неотрицательных чисел, задающих положение каждой ножки. Положение ножки определяется расстоянием от левого края плиты до левого края ножки (ножка - это куб размером 1×1×1). Ножки перечислены слева направо (то есть начиная с ножки с меньшим расстоянием до левого края).
Формат вывода
Требуется перечислить ножки, которые студентам нужно оставить. Для каждой ножки нужно выдать ее положение, как оно задано во входных данных. Ножки следует перечислять слева направо, в том порядке, в котором они встречаются во входных данных.
Пример 1
Ввод	
5 2
0 2
Вывод
2
Пример 2
Ввод	
13 4
1 4 8 11
Вывод
4 8
Пример 3
Ввод	
14 6
1 6 8 11 12 13
Вывод
6 8
]]></description>
    </test>
    <test id="116" subject="Сортировка по близости" testSetFolder="z1NearestToK">
      <description><![CDATA[Вводится размерность двумерной целочисленной матрицы n*n и число k, затем построчно все элементы этой матрицы. Нужно отсортировать каждый столбец матрицы по близости элементов к числу k (сначала самые близкие к К). Вывести полученную матрицу.
Примечание: при одинаковой близости сначала должен располагаться меньший элемент.
Примеры:
Ввод:
3 5
1 2 4
3 1 6
6 6 5
Вывод:
6 6 5
3 2 4
1 1 6
Ввод:
2 0
1 2
3 -1
Вывод:
1 -1
3 2
Ввод:
1 10
1
Вывод:
1]]></description>
    </test>
    <test id="117" subject="Таблица умножения" testSetFolder="z1TableOfMult">
      <description><![CDATA[Когда-то давно на обороте школьных тетрадок печатали таблицу умножения. Для каждого i от 1 до 10 был выписан свой набор произведений: для каждого j от 1 до 10 было явно записано, чему равно произведение i на j (смотрите пример). Вам нужно напечатать таблицу умножения в таком же формате.
Формат ввода
Даны целые числа m1, m2 и n1, n2, по модулю не превосходящие 100, причём m1 < m2 и n1 < n2.
Формат вывода
Для всех целых m из отрезка [m1, m2] напечатайте блок из произведений текущего числа m на все целые числа из [n1, n2], как показано в примере. Соседние блоки разделяйте пустой строкой.
*Пример
*
Ввод	
3 5
1 10
Вывод
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30
4 x 1 = 4
4 x 2 = 8
4 x 3 = 12
4 x 4 = 16
4 x 5 = 20
4 x 6 = 24
4 x 7 = 28
4 x 8 = 32
4 x 9 = 36
4 x 10 = 40
5 x 1 = 5
5 x 2 = 10
5 x 3 = 15
5 x 4 = 20
5 x 5 = 25
5 x 6 = 30
5 x 7 = 35
5 x 8 = 40
5 x 9 = 45
5 x 10 = 50
]]></description>
    </test>
    <test id="118" subject="Cтолбцы по убыванию значений элементов" testSetFolder="z1MatrixSort">
      <description><![CDATA[Отсортировать в матрице столбцы по убыванию значений элементов в первой строке.
В первой строке вводится размер матрицы, далее матрица задается построчно.
Пример:
Ввод:
4 4
1 2 3 5
1 2 3 4
3 2 3 1
3 2 1 3
Вывод:
5 3 2 1
4 3 2 1
1 3 2 3
3 1 2 3]]></description>
    </test>
    <test id="119" subject="Заменить пробел и группы пробелов символом" testSetFolder="z1StarsAndSpaces">
      <description><![CDATA[Дана строка слов, разделенных пробелами. Между словами может быть несколько пробелов, в начале и конце строки также могут быть пробелы. Требуется преобразовать строку так, чтобы в ее начале и конце пробелов не было, а слова были разделены одиночным символом "*" (звездочка).
Пример, 
Ввод:
Мама мыла раму
Вывод
Мама*мыла*раму]]></description>
    </test>
    <test id="120" subject="Правильная расстановка ударений" testSetFolder="accentQuiz">
      <description><![CDATA[У Васи домашняя работа — в заданном тексте расставить ударения в словах, после чего поручила Ире проверку. Ира очень плохо знакома с данной темой, поэтому она нашла словарь, в котором указано, как ставятся ударения в словах.
К сожалению, в этом словаре присутствуют не все слова. Ира решила, что в словах, которых нет в словаре, она будет считать, что Вася поставил ударения правильно, если в этом слове Васей поставлено ровно одно ударение. 
Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Ира решила, что в этом случае если то, как Вася поставил ударение, соответствует одному из приведенных в словаре вариантов, она будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку.
 Вам дан словарь, которым пользовалась Ира и домашнее задание, сданное Васей. Определите количество ошибок, которое в этом задании найдет Ира.
Формат ввода
Вводится сначала число N — количество слов в словаре (0≤N≤20000). Далее идет N строк со словами из словаря. Каждое слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв. В каждом слове заглавная ровно одна буква — та, на которую попадает ударение. Слова в словаре расположены в алфавитном порядке. Если есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут в произвольном порядке. Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста, суммарным объемом не более 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним пробелом. Длина каждого слова не превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв (заглавными обозначены те буквы, над которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить ударения вовсе.
Формат вывода
Выведите количество ошибок в Васином тексте, которые найдет Ира.
*Пример 1*
Ввод	
4
cAnnot
cannOt
fOund
pAge
thE pAge cAnnot be found
Вывод
2
*Пример 2*
Ввод	Вывод
4
cAnnot
cannOt
fOund
pAge
The PAGE cannot be found
4
Примечания
Примечания к примерам тестов
1. В слове cannot, согласно словарю возможно два варианта расстановки ударения. Эти варианты в словаре могут быть перечислены в любом порядке (т.е. как сначала cAnnot, а потом cannOt, так и наоборот). Две ошибки, совершенные Васей — это слова *be* (ударение вообще не поставлено) и *fouNd* (ударение поставлено неверно). Слово thE отсутствует в словаре, но поскольку в нем Вася поставил ровно одно ударение, признается верным. 
2. Неверно расставлены ударения во всех словах, кроме *The* (оно отсутствует в словаре, в нем поставлено ровно одно ударение). В остальных словах либо ударные все буквы (в слове PAGE), либо не поставлено ни одного ударения.]]></description>
    </test>
    <test id="121" subject="Отражение матрицы" testSetFolder="z1MatrixReflection">
      <description><![CDATA[Вам на вход поступает диагональная матрица NxN целых чисел, т.е. матрица, в которой нули над главной диагональю.
Вам необходимо ее зеркально отразить относительно главной диагонали.
Выведите также среднее арифметическое ненулевых элементов матрицы, результат округлите вниз до целого.
+Пример 1:+
Ввод:
1  0 0
2 2 0
3 3 3
Вывод:
1 2 3 
0 2 3
0 0 3
2
+Пример 2:+
Ввод:
3
Вывод:
3
3]]></description>
    </test>
    <test id="122" subject="Сумма произведений соседних чисел" testSetFolder="sumOfNeibors">
      <description><![CDATA[По данному натуральному n≥2 вычислите сумму 1×2+2×3+...+(n-1)×n. Ответ выведите в виде вычисленного выражение и его значения *в точности*, как показано в примере.
+Формат ввода+
Вводится натуральное число.
+Формат вывода+
Выведите ответ на задачу.
*Пример 1*
+Ввод+	
4
+Вывод+
1*2+2*3+3*4=20
*Пример 2*
+Ввод+	
2
+Вывод+
1*2=2
*Пример 3*
+Ввод+	
3
+Вывод+
1*2+2*3=8
В случае некорректных входных данных выведите "ERROR".]]></description>
    </test>
    <test id="123" subject="Общий префикс" testSetFolder="commonPrefix">
      <description><![CDATA[Напишите программу, вычисляющую длину наибольшего общего префикса двух строк. Префиксом строки называется любая начальная подстрока этой строки.
Формат ввода
На входе даны две текстовых строки, состоящие из букв латинского алфавита в различных регистрах. Длина строк не превосходит 1000 символов.
Формат вывода
Напечатайте длину наибольшего общего префикса этих строк.
Пример 1
Ввод	
apple
apricot
Вывод
2
Пример 2
Ввод	
apple
Apple
Вывод
5]]></description>
    </test>
    <test id="124" subject="Поисковые запросы" testSetFolder="finalQueezeSearch">
      <description><![CDATA[Задача:
Разбить предложение на слова(токены). Это может быть полезно, например, для поисковой системы.
Есть несколько правил:
*1. Несколько слов в кавычках должны попасть в один токен*
This "huge test" is pointless => this,huge test,is,pointless
*2. Слова написанные через дефис так же попадают в один токен.
Слова написанные через несколько дефисов, или имеющие дефис в начале или в конце попадают в раздельные токены.*
Suzie Smith-Hopper test--hyphens => Suzie,Smith-Hopper,test,hyphens.
*3. Сокращения (стяжения) попадают в один токен*
I can't do it => I,can't,do,it.
*4. Вся пунктуация кроме апострофов и дефисов должна быть убрана.*
Too long; didn't read => Too,long,didn't,read.]]></description>
    </test>
    <test id="269" subject="Самая длинная общая часть последовательностей" testSetFolder="z1EqualSequences">
      <description>
	  <![CDATA[Для 3х последовательностей целых чисел вам необходимо определить длину самой большой их общей части.
На вход поступают последовательности целых чисел (обязательно их хранить в виде целых чисел).
Необходимо вывести одно число - длину самой большой общей их части.
Пример 1.
Ввод:
1 2 3 4 5
2 3 4 5 6 7
3 4 5
Вывод:
3
Пример 1.
Ввод:
1 2 3 4 5
2 2 2 2 2 2 2
3 42 5
Вывод:
0]]>
</description>
    </test>
    <test id="270" subject="Максимальная добыча" testSetFolder="z1MaxLoot">
      <description>
	  <![CDATA[В сокровищнице пиратов гораздо больше различных ценностей, чем может поместиться в сундук.
Нужно определить самую ценную комбинацию различных драгоценных предметов, исходя из предположения, что любую часть предмета можно положить в сундук, карманов и других средств для транспортировки под руками у вас нет.
Вам нужно написать программу, которая бы решала эту проблему.
Входные данные. В первой строке входных данных содержится число 𝑛 - количество ценных предметов и 𝑊 размер вашего сундука.	
Следующие 𝑛 строк определяют ценность и размер предметов: целые числа V𝑖 и W𝑖 в каждой строке — ценность и размер 𝑖-го предмета соответственно.
Все 1 ≤ 𝑖 ≤ 𝑛. числа - целые.
Вам нужно вывести максимальную ценность всех предметов, которые влезут в сундук.
Ответ округляйте до 2х знаков после запятой.
Пример 1
Ввод
3 50
60 20
100 50
120 30
Вывод:
180
Комментарий : чтобы достичь ценности в 180 единиц, нужно взять первый предмет целиком и третий предмет целиком.
Пример 2
Ввод:
1 10
500 30
Вывод:
166.67
В наш сундук влезла всего треть от единственного предмета.]]>
</description>
    </test>
    <test id="9276" subject="Ваша зарплата" testSetFolder="z1Salary">
      <description><![CDATA[Ходят слухи, что на job interview в одной большой технологической кампании был такой случай. Кандидат John, уже успешно прошел все "круги собеседования", и в конце на согласовании зарплаты ему сообщили следующее:
- Вы молодец, John, вот вам несколько карточек с цифрами и числами, сложите из них число и это будет вашей зарплатой в нашей компании.
Ваша же задача помочь соискателю.
На вход вашей программе поступает строка, содержащая цифры и/или числа. Выведите максимальную зарплату, которую может получить John.
Обратите внимание на примеры. Можно конкатенировать строки или работать с числами на ваше усмотрение, но карточек может быть много, и числа на них могут быть разумно большими.
Пример 1:
Ввод:
1 2 3
Вывод:
321
Пример 2:
Ввод:
27 34 90
Вывод:
903427
Пример 3:
Ввод:
21 2
Вывод:
221]]></description>
    </test>
    <test id="9277" subject="Прямые углы" testSetFolder="z1SquareCorners">
      <description><![CDATA[Имеется набор точек в N-мерном пространстве. Каждая точка имеет название. Гарантируется, что все точки различны. Требуется найти на чертеже все прямоугольные треугольники с вершинами в этих точках.
Формат ввода
Сначала задано число N — размерность пространства. Известно, что 2 <= N <= 100.
Далее задано число M — количество точек (1 <= M <= 20). Следующие M строк состоят из названия точки (непустая строка из латинских букв или цифр длиной до 10 символов) и N её координат. Все координаты — целые числа в диапазоне от -10^6 до 10^6.
Формат вывода
Напечатайте в каждой строке имена вершин прямоугольных треугольников на этом чертеже. Вершины треугольника следует задавать в формате A B C, так, чтобы угол B был бы прямым, а точка A шла бы в исходном списке точек раньше точки C. Все вершины треугольников должны иметь разные имена. Треугольники должны быть упорядочены по первым вершинам (не по их названиям), затем - по вторым, потом - по третьим. Сами вершины при этом должны иметь тот же порядок, что и в исходном списке.
*Пример 1*
 Ввод	
2
3
A 1 0
B 0 0
C 0 1
Вывод
A B C
*Пример 2* 
Ввод	
2
4
A 1 0
B 0 0
C 0 1
D 1 1
Вывод
A B C
A D C
B A D
B C D
*Примечание*
Угол между векторами u = (u1, …, uN) и v = (v1, …, vN) в N-мерном пространстве будет прямым, если скалярное произведение  !https://i.ibb.co/zQPbj1M/scalar.png! равно нулю.]]></description>
    </test>
    <test id="9279" subject="Прыжки лягушки" testSetFolder="z1JumpGame2">
      <description><![CDATA[Вам на вход поступает массив целых чисел длины n. Лягушка изначально "сидит" в клетке с интексом 0.
Каждый элемент массива numbers[i] представляет из себя число - максимальную возможную длину прыжка лягушки из этой клетки. 
Вам нужно рассчитать для данного массива минимальное количество прыжков, которое необходимо лягушке для того, чтобы "оказаться" в последнем элементе массива.
*Пример 1*
Ввод:
[2, 3, 1, 1, 4]
Вывод: 
2
Примечание: Первым прыжком можно прыгнуть в numbers[1], затем вторым - на последний элемент.
*Пример 2*
Ввод:
[2, 3, 0, 1, 4]
Вывод:
2]]></description>
    </test>
    <test id="9280" subject="Составляем крутое название компании" testSetFolder="z1NamingACompany">
      <description><![CDATA[Вам дан массив слов идей, который представляет собой список имен, которые будут использоваться в процессе именования компании. Процесс присвоения имени компании выглядит следующим образом:
Выберите 2 разных имени из идей, назовите их идеяА и идеяБ.
Поменяйте местами первые буквы ideaA и ideaB.
Если оба новых имени не встречаются в исходных идеях, то допустимым названием компании является имя "ideaA ideaB" (объединение ideaA и ideaB, разделенных пробелом).
В противном случае это недопустимое имя.
Вам нужно вернуть количество различных допустимых имен для компании.
Все слова в исходном массиве уникальные и состоят и маленьких букв латинского алфавита.
*Пример 1:*
Ввод:
["coffee","donuts","time","toffee"]
Вывод: 
6
Примечание: допустимы следующие варианты:
- ("coffee", "donuts"): созданное название компании - "doffee conuts".
- ("donuts", "coffee"): созданное название компании - "conuts doffee".
- ("donuts", "time"): созданное название компании "tonuts dime".
- ("donuts", "toffee"): созданное название компании - "tonuts doffee".
- ("time", "donuts"): созданное название компании - "dime tonuts".
- ("toffee", "donuts"): созданное название компании - "doffee tonuts".
Таким образом, всего существует 6 различных названий компаний.
Ниже приведены некоторые примеры недопустимого выбора:
- ("coffee", "time"): Образованное после обмена буквами слово "toffee" уже существует в исходном массиве.
- ("time", "toffee"): оба имени остаются прежними после замены и существуют в исходном массиве.
- ("coffee", "toffee"): Оба имени, образованные после обмена буквами, уже существуют в исходном массиве.
*Пример 2*
Ввод: 
["lack","back"]
Вывод:
0]]></description>
    </test>
  </homework>
  <homework id="700" name="Курсера.Алгоритмы">
    <test id="701" subject="Сколько до заправки?" testSetFolder="carFuelling">
      <description><![CDATA[
Вы собираетесь в другой город, расположенный на _d_ километров от вас. Ваш автомобиль может проехать максимум _m_  километров на полном баке. Заправки расположены на расстояниях _stop1_ , _stop1_ , _stopN_ от вашего города.
Какое минимальное количество остановок для дозаправки вам будет необходимо сделать?
На вход программе поступает целое число _𝑑_ . Во второй строке целое 𝑚. Третья строка содержит количество заправок _𝑛_ . И, наконец, четвертая содержит километровые отметки этих заправок.
Вывод. Выведите минимально число остановок для дозаправки по пути. Предполагается, что стартуем с полным баком. Если во введенным данным достичь пункта назначения невозможно, выведите −1.
*Ограничения*
 1 ≤ 𝑑 ≤ 10^5
 1 ≤ 𝑚 ≤ 400
 1 ≤ 𝑛 ≤ 300
 0 < stop1 < stop2 < · · · < stop𝑛 < 𝑑.
*Пример 1.*
Ввод:
950
400
4
200 375 550 750
Вывод:
2
Примечание: Расстояние между городами – 950км, полного бака хватает максимум на 400 км on. Достаточно сделать 2 остановки: на 375км и 750км.
*Пример 2.*
Ввод:
10
3
4
1 2 5 9
Вывод:
-1
Никаким образом невозможно преодолеть расстояния на данной машине между 5 км и 9 км.
*Пример 3.*
Ввод:
200
250
2
100 150
Вывод:
0
Можем не заправляться, топлива достаточно.
]]></description>
    </test>
    <test id="268" subject="Разменнная монета" testSetFolder="z1moneyChange">
      <description><![CDATA[В некоторой заморской стране довольно необычная система монет: существуют только монеты 1, 3, 4 песо.
Вам нужно найти способ как выдать сдачу в _N_ песо используя минимальное число монет.
Входной формат данных. Целое число - необходимая сдача.
Выходной формат. Минимальное количество монет из набора 1, 3, 4, и пример получившейся суммы, где монеты упорядочены по возрастанию номинала.
*Пример 1*
Ввод:
2
Вывод:
2
2 = 1 + 1
*Пример 2*
Ввод:
34
Вывод:
9
34 = 3 + 3 + 4 + 4 + 4 + 4 + 4 + 4 + 4]]>
</description>
    </test>
    <test id="702" subject="Мешок с сокровищами - 1" testSetFolder="fractionalKnapsnack">
      <description><![CDATA[Вы попали в сокровищницу, у вас с собой есть только один мешок известного размера. Нужно подобрать различные виды драгоценностей так, чтобы стоимость вашего мешка была максимальной. Можно брать с собой любую часть "драгоценности".
В первой строке вхождных данных содержится количество "драгоценностей" ( _itemsTotal_ ) и размер вашего мешка _MaxWeight_.
Следующие _itemsTotal_  строк определяют ценности и веса "драгоценностей".
𝑖-я строка содержит целое 𝑣𝑖 and 𝑤𝑖 — соответственно ценность и вес 𝑖-ой драгоценности.
Все входные данные данные целые, но могут быть очень большими.
Выходные данные: с точностью до 4го знака максимальная стоимость вашего мешка. 
*Пример 1.*
Ввод:
3 50
60 20
100 50
120 30
*Вывод:*
180.0000 (или 180)
Чтобы получить 180 мы должны взять первую и третью драгоценность целиком.
*Пример 2.*
Ввод:
1 10
500 30
Вывод:
166.6667
Тут мы просто берем треть единственной доступной драгоценности.
]]></description>
    </test>
    <test id="703" subject="Максимизация прибыли от рекламы" testSetFolder="adsRevenue">
      <description><![CDATA[У вас есть _n_ рекламных баннеров, которые можно разместить на интернет-странице. Для каждого баннера известно сколько вам заплатят за каждый клик. У вас _n_ слотов на странице и есть оценка ожидаемого количества кликов в день на каждый слот. Ваша цель: разместить баннеры по слотам так, чтобы максимизировать прибыль.
Заданы две последовательности:
_𝑎1, 𝑎2, . . . , 𝑎𝑛_  _(𝑎𝑖_  вознаграждение за клик на 𝑖-ом баненре) 
_𝑏1, 𝑏2, . . . , 𝑏𝑛_  ( _𝑏𝑖_ среднее количество кликов на 𝑖-й слот)
По сути: задача выделить 𝑛 пар (𝑎𝑖 , 𝑏𝑗 ) так, чтобы их сумма произведений была максимальной и вывести это значение.
В первой строке данных – количество элементов списка, все цисла - целые.
+Пример 1+
Ввод:
1
23
39
Вывод:
897 
(897 = 23 x 39).
+Пример 2+
Ввод:
3
1 3 -5
-2 4 1 
Вывод: 
23 
(23 = 3 х 4 + 1 х 1 + (−5) х (−2) ).]]></description>
    </test>
    <test id="9275" subject="Перепись населения" testSetFolder="courseraSignatures">
      <description><![CDATA[Вам нужно переписать население и собрать подписи жильцов дома. Известны временные интервалы, когда жильцы назодятся дома. Рассчитайте, сколько раз вам нужно посетить этот дом и в какое время.
Формат ввода: В первой строке содержится количество жильцов - tenants. Далее, в tenants строках содержатся периоды времени, когда этот жилец находится дома.
Формат вывода: минимальное количество визитов и часы визитов через пробел. Если вариантов несколько, выбирайте минимальный. Порядок вывода - по возрастанию.
Для простоты все значения целые, значения находятся в диапазоне 0-23. Считается, что если даже человек уходит из дома в час визита, его все же можно "поймать на выходе", см. примеры.
Пример 1:
Ввод:
3
1 3
2 5
3 6
Вывод:
1
3
Все 3 интервала (длиной 2, 3, 3 соответственно) имеют одну точку пересечения - 3.
Пример 2:
Ввод:
4
4 7
1 3
2 5
5 6
Вывод:
2
3 6
или
Вывод:
2
2 5
Если в задаче более одного возможного ответа, будут принят любой из правильных.]]></description>
    </test>
    <test id="9278" subject="Наибольший общий делитель строк" testSetFolder="Naibolshiiobschiidelitelstrok">
      <description><![CDATA[Для двух строк s и t мы говорим «t делит s» тогда и только тогда, когда s = t + ... + t (т. е. t объединяется сама с собой один или несколько раз).
Имея две строки str1 и str2, верните наибольшую строку x, на которую x делится как на str1, так и на str2.
Пример 1:
Ввод: 
ABCABC
ABC
Вывод: 
ABC
Пример 2:
Ввод: 
ABABAB
ABAB
Вывод:
AB
Пример 3:
GREAT
SUBJECT
Вывод:
0 
Ограничения:
1 <= str1.length, str2.length <= 1000
str1 и str2 состоят из английских заглавных букв.
Время выполнения программы - 1 секунда.]]></description>
    </test>
  </homework>
  <homework id="125" name="Date and Time">
    <test id="126" subject="Рабочие будни" testSetFolder="dateTime_workDays">
      <description><![CDATA[Задана дата. Сгенерировать расписание с этой даты *на следующий месяц* по такому принципу: сутки через трое. Если рабочий день приходится на воскресенье, то он переносится на понедельник.  В итоге необходимо вывести даты рабочих дней.  Напрмер, если введено 4 февраля 2021, то необходимо сгенерировать расписание по 4 марта вклюительно.
*Пример:*
Ввод:
13.2.2021
Вывод:
13.2.2021
17.2.2021
22.2.2021
26.2.2021
2.3.2021
6.3.2021
10.3.2021
Примечание: Если через месяц от введенного дня день попадает на рабочий, его тоже надо выводить.
21.2.2021 - попадает на воскресенье, значит следующий рабочий день - 22.2.2021]]></description>
    </test>
    <test id="127" subject="Учет времени выполнения задач" testSetFolder="dateTime_timeManagement">
      <description><![CDATA[Дан массив периодов дат (временные затраты сотрудника на выполнение задач проекта).
Например, 
[{'start': '02.10.2021 10:12:11', 'end':'02.10.2021 15:20:11'}, ['start':'03.10.2021 13:12:11', 'end':'03.10.2021 16:40:40'}]
То есть это массив, каждый элемент - словарь с двумя датами в формате ‘DD.MM.YY HH:MM:SS’. 
Найти, сколько всего часов потрачено сотрудником. Ответ вывести в в формате "N-K", где N - количество часов, K-количество минут.
Например,
Ввод:
[{'start': ’25.01.2021 10:00:11', 'end':'25.01.2021 15:00:09'}, {'start':'25.01.2021 15:10:11', 'end':'25.01.2021 16:40:40'}];
Вывод:
6-30
Примечание:
Секунды округляются всегда вниз.
Если работа велась ночью/в выходные необходимо учитывать весь период.]]></description>
    </test>
    <test id="128" subject="Система бронирования отелей" testSetFolder="dateTime_hotels">
      <description><![CDATA[В одной системе бронирования отелей вам надо написать один небольшой модуль.
Вам дан массив дат бронирования номера в отеле. Элемент массива или одна дата, или период - две даты через дефис. 
Пример: 
['12.09.2020', '14.09.2020-02.10.2020']
Вам надо выяснить можно ли добавить в массив новую введенную дату или период для нового бронирования. Например, для указанного выше примера период '01.10.2020-05.10.2020' добавлять нельзя, так как первые два дня уже забронированы.
В первой строке входных данных содержится информация о дате-времени существующих бронирований, во второй - новая бронь.
Выведите True, если бронь можно добавить, False - если нельзя.
*Пример 1:*
Ввод:
['12.09.2020', '14.09.2020-02.10.2020']
01.10.2020-05.10.2020
Вывод:
False
*Пример 2:*
Ввод:
['14.09.2020-02.10.2020']
31.12.2020
Вывод:
True]]></description>
    </test>
    <test id="261" subject="Посетители музея" testSetFolder="date_time_museum">
      <description><![CDATA[В музее регистрируется в течение дня время прихода и ухода каждого посетителя. Таким образом за день получены N пар значений, где первое значение в паре показывает время прихода посетителя и второе значения - время его ухода. Найти промежуток времени, в течение которого в музее одновременно находилось максимальное число посетителей.
Пример:
Входные данные:
9:00 17:15
10:00 11:00
Ожидаемый результат
10:00 11:00]]></description>
    </test>
  </homework>
  <homework name="Лабораторная работа 0">
    <test id="129" subject="Удаление одинаковых элементов массива" testSetFolder="Udalenieodinakovyhelementovmassiva">
      <description><![CDATA[Требуется из заданного массива сделать новый, удалив все повторы каждого элемента.]]></description>
    </test>
    <test id="130" subject="Выбор элементов массива 1" testSetFolder="Vyborelementovmassiva1">
      <description><![CDATA[Требуется из одного массива скопировать в другой массив все элементы по возрастанию.]]></description>
    </test>
    <test id="131" subject="Выбор элементов массива 2" testSetFolder="Vyborelementovmassiva2">
      <description><![CDATA[Требуется из одного массива скопировать в другой массив все четные по значению элементы.]]></description>
    </test>
    <test id="132" subject="Исключение одинаковых элементов массива" testSetFolder="Isklyuchenieodinakovyhelementovmassiva">
      <description><![CDATA[Требуется для заданного массива заменить на "0" все повторяющиеся элементы, например,
для массив (1,2,1,1,3) нужно преобразовать в (1,2,0,0,3).]]></description>
    </test>
    <test id="133" subject="Сумма и произведение элементов одномерного массива" testSetFolder="Summaiproizvedenieelementovodnomernogomassiva">
      <description><![CDATA[Требуется вычислить сумму и произведение элементов одномерного массива случайных дробных чисел с 2мя знаками после запятой.]]></description>
    </test>
    <test id="134" subject="Заполнение массива и вычисление суммы элементов" testSetFolder="Zapolneniemassivaivychisleniesummyelementov">
      <description><![CDATA[Требуется заполнить массив числами, которые вводит пользователь, и вычислить сумму всех введенных чисел.]]></description>
    </test>
    <test id="135" subject="Максимальный по модулю элемент массива" testSetFolder="Maksimalьnyipomodulyuelementmassiva">
      <description><![CDATA[В массиве, заполненном целыми случайными числами из диапазона [-1000, 1000], найти максимальный по модулю элемент.]]></description>
    </test>
    <test id="136" subject="Сумма элементов частей массива" testSetFolder="Summaelementovchasteimassiva">
      <description><![CDATA[Какая сумма элементов массива больше – с первого до элемента с номером К или от элемента с номером К до последнего.]]></description>
    </test>
    <test id="137" subject="Поиск максимального элемента в массиве" testSetFolder="Poiskmaksimalьnogoelementavmassive">
      <description><![CDATA[Найти максимальный элемент численного массива.]]></description>
    </test>
    <test id="138" subject="Определить возможность существования треугольника по сторонам" testSetFolder="triangle">
      <description><![CDATA[Треугольник существует только тогда, когда сумма любых двух его сторон больше третьей. Вводятся длины сторон треугольника, вывести сообщение о возможности существования треугольника с такими длинами сторон.]]></description>
    </test>
    <test id="139" subject="&quot;Переворот&quot; числа" testSetFolder="PerevorotChisla">
      <description><![CDATA[Вводится число. Преобразовать его в другое число, цифры которого будут следовать в обратном порядке по сравнению с введенным числом.]]></description>
    </test>
    <test id="140" subject="Произведение первого, третьего и шестого положительных элементов массива" testSetFolder="ProizvedenieElementovmassiva">
      <description><![CDATA[Для одномерного массива вычислить произведение первого, третьего и шестого положительных элементов и определить их номера в массиве.]]></description>
    </test>
    <test id="141" subject="Поразрядное сравнение чисел" testSetFolder="Porazryadnoesravneniechisel">
      <description><![CDATA[Для двух введенных пятизначных чисел определить количество совпадений в них цифр, стоящих в одинаковых разрядах. (Например, для чисел 12345 и 13285, результат - 2)]]></description>
    </test>
    <test id="142" subject="Длина последовательности" testSetFolder="Dlinaposledovatelnosti">
      <description><![CDATA[Определить в одномерном массиве длину самой большой повторяющейся последовательности одинаковых элементов.]]></description>
    </test>
    <test id="143" subject="Поиск среднего элемента в массиве" testSetFolder="Poisksrednegoelementavmassive">
      <description><![CDATA[Требуется найти среднее значение элементов одномерного массива.]]></description>
    </test>
    <test id="144" subject="Вычисление площадей геометрических фигур" testSetFolder="Vychislenieploschadeifigur">
      <description><![CDATA[Вводятся длины сторон прямоугольника, найти его площадь и периметр.]]></description>
    </test>
    <test id="145" subject="Вывести все возможные варианты трехзначного числа" testSetFolder="Trehznachnogochisla">
      <description><![CDATA[Дано трехзначное число. Вывести на экран все трехзначные числа, которые можно получить из цифр данного числа.]]></description>
    </test>
    <test id="146" subject="Определение различных цифр, входящих в число" testSetFolder="Opredelenierazlichnyhcifr">
      <description><![CDATA[Требуется определить сколько различных цифр входит в заданное число]]></description>
    </test>
    <test id="147" subject="Поменять столбцы местами" testSetFolder="Pomenyatьstolbcymestami">
      <description><![CDATA[Поменять местами столбцы в матрице, состоящих из n строк и двух столбцов.]]></description>
    </test>
  </homework>
  <homework name="Лабораторная работа 1. Дерево функций">
    <test id="148" subject="Игра &quot;Мафия&quot;" testSetFolder="Mafiya">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="149" subject="Игра &quot;Лего&quot;" testSetFolder="Lego">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="150" subject="Игра &quot;Сапер&quot;" testSetFolder="Saper">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="151" subject="Пасьянс &quot;Косынка&quot;" testSetFolder="Kosynka">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="152" subject="Игра &quot;Сolour lines&quot;" testSetFolder="Solourlines">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="153" subject="Игра &quot;Раскраска&quot;" testSetFolder="Raskraska">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="154" subject="Игра &quot;Hexxagon&quot;" testSetFolder="Hexxagon">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="155" subject="Игра &quot;Нарды&quot;" testSetFolder="Nardy">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="156" subject="Игра &quot;Балда&quot;" testSetFolder="Balda">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="157" subject="Игра &quot;Морской бой&quot;" testSetFolder="Morskoiboi">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="158" subject="Игра &quot;Дартс&quot;" testSetFolder="Darts">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="159" subject="Игра &quot;Арканоид&quot;" testSetFolder="Arkanoid">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="160" subject="Игра &quot;Тетрис&quot;" testSetFolder="Tetris">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="161" subject="Карточная игра &quot;Очко&quot;" testSetFolder="KartochnayaOchko">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="162" subject="Игра &quot;Кубики&quot;(Dice)" testSetFolder="Kubiki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="163" subject="Сканворд" testSetFolder="Skanvord">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="164" subject="Игра &quot;Эластомания&quot;" testSetFolder="Elastomaniya">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="165" subject="Игра &quot;Кто хочет стать миллионером&quot;" testSetFolder="Ktohochetstatmillionerom">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="166" subject="Игра &quot;Поддавки&quot;" testSetFolder="Poddavki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="167" subject="Игра &quot;Шахматы&quot; " testSetFolder="Shahmaty">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="168" subject="Игра &quot;Шашки&quot;" testSetFolder="Shashki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="169" subject="Карточная игра &quot;Flappy Bird&quot;" testSetFolder="KartochnayaFlappyBird">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.
]]></description>
    </test>
    <test id="170" subject="Карточная игра &quot;Дурак&quot;" testSetFolder="KartochnayaDurak">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="171" subject="Игра &quot;Танки&quot;" testSetFolder="Tanki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="172" subject="Игра &quot;Гонки&quot;" testSetFolder="Gonki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="173" subject="Игра &quot;Супер Марио&quot;" testSetFolder="SuperMario">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="174" subject="Игра &quot;Сolour lines&quot;" testSetFolder="Solourlines">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="175" subject="Игра &quot;Раскраска&quot;" testSetFolder="Raskraska">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="176" subject="Игра &quot;Hexxagon&quot;" testSetFolder="Hexxagon">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="177" subject="Игра &quot;Нарды&quot;" testSetFolder="Nardy">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="178" subject="Игра &quot;Балда&quot;" testSetFolder="Balda">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="179" subject="Игра &quot;Морской бой&quot;" testSetFolder="Morskoiboi">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="180" subject="Игра &quot;Дартс&quot;" testSetFolder="Darts">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="181" subject="Игра &quot;Арканоид&quot;" testSetFolder="Arkanoid">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="182" subject="Игра &quot;Тетрис&quot;" testSetFolder="Tetris">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="183" subject="Карточная игра &quot;Очко&quot;" testSetFolder="KartochnayaOchko">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="184" subject="Игра &quot;Кубики&quot; (Dice)" testSetFolder="Kubiki(Dice)">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="185" subject="Игра &quot;Эластомания&quot;" testSetFolder="Elastomaniya">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="186" subject="Игра &quot;Кто хочет стать миллионером&quot;" testSetFolder="Ktohochetstatьmillionerom">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="187" subject="Игра &quot;Поддавки&quot;" testSetFolder="Poddavki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="188" subject="Игра &quot;Шахматы&quot; " testSetFolder="Shahmaty">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="189" subject="Игра &quot;Шашки&quot;" testSetFolder="Shashki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="190" subject="Карточная игра &quot;Flappy Bird&quot;" testSetFolder="KartochnayaFlappyBird">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.
]]></description>
    </test>
    <test id="191" subject="Карточная игра &quot;Дурак&quot;" testSetFolder="KartochnayaDurak">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="192" subject="Игра &quot;Танки&quot;" testSetFolder="Tanki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="193" subject="Игра &quot;Гонки&quot;" testSetFolder="Gonki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
  </homework>
  <homework name="Лабораторная работа 5. Классы">
    <test id="194" subject="Игра &quot;Мафия&quot;" testSetFolder="Mafiya">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="195" subject="Игра &quot;Кубики&quot; (Dice)" testSetFolder="Kubiki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="196" subject="Игра &quot;Лего&quot;" testSetFolder="Lego">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="197" subject="Игра &quot;Сапер&quot;" testSetFolder="Saper">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="198" subject="Пасьянс &quot;Косынка&quot;" testSetFolder="Kosynka">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="199" subject="Игра &quot;Сolour lines&quot;" testSetFolder="Solourlines">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="200" subject="Игра &quot;Hexxagon&quot;" testSetFolder="Hexxagon">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="201" subject="Игра &quot;Шашки&quot;" testSetFolder="Shashki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="202" subject="Карточная игра &quot;Flappy Bird&quot;" testSetFolder="KartochnayaFlappyBird">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.
]]></description>
    </test>
    <test id="203" subject="Игра &quot;Танки&quot;" testSetFolder="Tanki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="204" subject="Игра &quot;Морской бой&quot;" testSetFolder="Morskoiboi">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="205" subject="Игра &quot;Дартс&quot;" testSetFolder="Darts">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="206" subject="Игра &quot;Гонки&quot;" testSetFolder="Gonki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить дерево функций.]]></description>
    </test>
    <test id="207" subject="Игра &quot;Тетрис&quot;" testSetFolder="Tetris">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="208" subject="Игра &quot;Раскраска&quot;" testSetFolder="Raskraska">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="209" subject="Игра &quot;Эластомания&quot;" testSetFolder="Elastomaniya">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="210" subject="Игра &quot;Кто хочет стать миллионером&quot;" testSetFolder="Ktohochetstatmillionerom">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="211" subject="Игра &quot;Поддавки&quot;" testSetFolder="Poddavki">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="212" subject="Игра &quot;Нарды&quot;" testSetFolder="Nardy">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="213" subject="Игра &quot;Шахматы&quot; " testSetFolder="Shahmaty">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="214" subject="Карточная игра &quot;Дурак&quot;" testSetFolder="KartochnayaDurak">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="215" subject="Игра &quot;Балда&quot;" testSetFolder="Balda">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="216" subject="Игра &quot;Арканоид&quot;" testSetFolder="Arkanoid">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
    <test id="217" subject="Игра &quot;Супер Марио&quot;" testSetFolder="SuperMario">
      <description><![CDATA[Задание: 
1. Описать правила игры.
2. Построить диаграмму классов.
3. Описать классы на языке Java (классы должны содержать заглушки методов вместо их реализации, но компилироватся и содержать JavaDoc-описания методов).
Сдать нужно 2 файла в формате PDF + код классов.]]></description>
    </test>
  </homework>
  <homework name="Лабораторная 8. Работа с данными в файлах">
    <test id="218" subject="Вариант 1. Работа со структурированными данными в файлах " testSetFolder="Variant1">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержатся в случайном порядке показания нескольких термометров, имя термометра и значение разделены символом ":"
+Например,+
<pre>
term1:12
term2:10
term1:3
term3:10
term2:15
</pre>
Найти среднее показание термометра под заданным номером (номер вводится с клавиатуры).
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Среднее показание термометра *N*: XX", если термометра нет, нужно выводить сообщение "Данных по термометру номер N не найдено".
]]></description>
    </test>
    <test id="219" subject="Вариант 4. Работа со структурированными данными в файлах" testSetFolder="Variant4">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержится данные о весе животных, кличка животного разделены, вес в кг и возраст разделены символом "-" и/или произвольным количеством пробелов.
+Например,+
<pre>
Федя - 150 - 2
Кузя-151- 2
Потап -    221 -1,5
</pre>
Требуется вывести самого тяжелого животного возрастом не старше 1,5 лет.
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
Формат вывода:
"Самое тяжелое животное не старше 1.5 лет: Потап - 221 кг", если такового нет, нужно выводить сообщение "Данных по самому тяжелому животному не старше 1.5 лет не найдено".
]]></description>
    </test>
    <test id="220" subject="Вариант 5. Работа со структурированными данными в файлах" testSetFolder="Variant5">
      <description><![CDATA[В текстовом файле содержится стоимость красок, файл представлен следующим образом.
+Например:+
<pre>
"красная":"300" 
"желтая":"400" 
"зеленая":"230" 
"желтая":"200" 
...
</pre>
Нужно вывести список цветов краски в консоль и рассчитать среднюю стоимость краски. 
Выбор краски осуществляется вводом цифры в консоли - номера краски в списке.
Результат или текст ошибки сохраняется в файл output.txt, кодировка UTF-8.
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Сумма в виде <цвет краски> - средняя стоимость (например, 200.50).
Если выбранной краски нет, выводить сообщение "Данных по краске <цвет> не найдено".]]></description>
    </test>
    <test id="221" subject="Вариант 6. Работа со структурированными данными в файлах" testSetFolder="Variant6">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251)  содержатся результаты футбольного турнира. Например,
<pre>
"Шайба","Игр-10""Очков 20" 
"Зубило","Игр-10""Очков 26" 
"Подшипник","Игр-10""Очков 23" 
...
</pre>
Определите победителя турнира, если сыграно одинаковое число игр, или выведите команду(ы) лидера(ов), если количество игр не одинаково.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
Формат вывода:
"Победитель турнира - "Зубило"", или "Текущий лидер - ХХХ".
]]></description>
    </test>
    <test id="222" subject="Вариант 7. Работа со структурированными данными в файлах" testSetFolder="Variant7">
      <description><![CDATA[В текстовом файле (input.txt, кодировка UTF-8) содержатся показания уровня топлива в баке, каждое измерение было сделано через час от предыдущего.
+Например:+
<pre>
Осталось: 300л
Осталось:290 л
Осталось: 279л
Осталось:270л.
....
</pre>
Определить средний расход топлива в день.
Результат или текст ошибки сохраняется в файл output.txt, кодировка UTF-8.
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Средний расход топлива в день - 270 л/дн.]]></description>
    </test>
    <test id="223" subject="Вариант 8. Работа со структурированными данными в файлах" testSetFolder="Variant8">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержатся показания спидометра автомобиля, 
каждое измерение было сделано через секунду от предыдущего, 
+например+
<pre>
"50" кмч
"55" кмч
"54" кмч
...
</pre>
Определить расстояние, которое проехал автомобиль.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
Формат вывода:
"Автомобиль проехал Х км".]]></description>
    </test>
    <test id="224" subject="Вариант 9. Работа со структурированными данными в файлах" testSetFolder="Variant9">
      <description><![CDATA[В текстовом файле (input.txt, кодировка UTF-8) содержатся результаты забега. 
+Например:+
<pre>
"Иванов","2 минуты 12сек"
"Кузнецов","1минута 10сек"
"Петров"," 2минуты 33сек"
"Сидоров","2минуты 44сек"
...
</pre>
Определить самого быстрого участника, вывести его фамилию и результат.
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Фамилия - результат.]]></description>
    </test>
    <test id="225" subject="Вариант 12. Работа со структурированными данными в файлах" testSetFolder="Variant12">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) заданы стороны треугольников.
+Например:+
<pre>
a=12,b=22,c=23
a=10,b=3,c=13
a=19,b=30,c=8
...
</pre>
Определить их площади. 
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Площадь треугольника со сторонами <значения сторон через запятую> равна <значение площади>.
При невозможности существования треугольника с такими длинами сторон выводить: Треугольник со сторонами <значения сторон через запятую> не существует.
]]></description>
    </test>
    <test id="226" subject="Вариант 15. Работа со структурированными данными в файлах" testSetFolder="Variant15">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержатся данные о тактовой частоте процессоров, файл представлен следующим образом.
+Например,+
<pre>
"cpu"="1ггц";
"cpu"="  1.5ГГЦ";
"cpu"="3.43 ггц"
</pre>
Требуется найти среднюю тактовую частоту работы всех процессоров.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Средняя тактовая частота ХХХ ГГц
]]></description>
    </test>
    <test id="227" subject="Вариант 16. Работа со структурированными данными в файлах" testSetFolder="Variant16">
      <description><![CDATA[В текстовом файле содержится средняя годовая температура в городах, файл представлен следующим образом.
+Например:+
<pre>
"москва":"10";"самара":"15";
"Воронеж":"10";"Одинцово":"15";  "мытищи":"15";
"сочи":"20"...
</pre>
Требуется найти города со средней готовой температурой больше 15 градусов.
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи или записи с уже встречавшимся городом с корректными данными, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"<Наименование города>: XX", если таких городов нет, нужно выводить сообщение "Данных о городах не найдено".
]]></description>
    </test>
    <test id="228" subject="Вариант 17. Работа со структурированными данными в файлах" testSetFolder="Variant17">
      <description><![CDATA[В текстовом файле (input.txt кодировка 1251) содержится стоимость машин, файл представлен следующим образом.
+Например,+
<pre>
"ауди":"30000000"
"опель":"500000"
"жигули":"230000"
"опель":"400000"
...
</pre>
Требуется найти общую стоимость всех машин марки, введенной клавиатуры.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Средняя стоимость машин марки <Опель> 500000." или "Автомобилей введенной марки не найдено"
]]></description>
    </test>
    <test id="229" subject="Вариант 18. Работа со структурированными данными в файлах" testSetFolder="Variant18">
      <description><![CDATA[В текстовом файле содержится наименование и стоимость товаров.
+Например:+
<pre>
"сыр":"70руб","20коп",
"молоко":"40руб","40коп",
"творог":"33руб","00коп",
"сыр":"72руб","20коп"
...
</pre>
Требуется рассчитать общую стоимость выбранного товара (наименование вводится с клавиатуры).
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Общая стоимость товара <наименование товара>: XX", если выбранного товара нет, нужно выводить сообщение "Данных по товару <наименование товара> не найдено".]]></description>
    </test>
    <test id="230" subject="Вариант 19. Работа со структурированными данными в файлах" testSetFolder="Variant19">
      <description><![CDATA[В текстовом файле (input.txt кодировка 1251) содержится показания вольтметра, номер измерения и значение разделены следующим образом.
+Например,+
<pre>
"1":"   220В",
"2":"221 В",
"3":"223В   ",
"2":"    220   В  "
...
</pre>
Требуется среднее значение показаний введенного с клавиатуры прибора.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Средняя значение показаний прибора номер Х - Y" или "Прибора номер Х не найдено"
]]></description>
    </test>
    <test id="231" subject="Вариант 2. Работа со структурированными данными в файлах" testSetFolder="Variant2">
      <description><![CDATA[В текстовом файле (input.txt, кодировка UTF-8) содержится зарплатная ведомость: имя сотрудника, отдел, и значение разделены "::"
+Например:+
<pre>
"Иванов"::"транспортный цех"::34000руб 10 коп
"Петров"::"отдел эксплуатации"::54000руб 10 коп
"Сидоров"::"отдел закупок"::50440руб 10 коп
...
</pre>
Требуется рассчитать сумму по заданному отделу, наименование которого вводится с клавиатуры. 
Результат или текст ошибки сохраняется в файл output.txt, кодировка UTF-8.
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Сумма в виде N руб. K коп. - <наименование отдела>.
Если отдела нет, выводить сообщение "Данных по отделу <наименование отдела> не найдено".]]></description>
    </test>
    <test id="232" subject="Вариант 3. Работа со структурированными данными в файлах" testSetFolder="Variant3">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержится список долгов по организациям. 
+Например:+
"ООО Рога и копыта","долг=100р00коп." 
"ООО СвияжСтрой","долг=1344р1коп." 
"ЗАО МИР", "долг=1р" 
"ООО СвияжСтрой","долг=1334р24коп." 
...
Нужно вывести в консоль список организаций и рассчитать общую сумму долга для выбранной организации. 
Выбор организации осуществляется вводом цифры в консоли - номера организации в списке.
Результат или текст ошибки сохраняется в файл output.txt, кодировка UTF-8.
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Сумма в виде N руб. K коп. - <наименование организации>.
Если организации нет, выводить сообщение "Данных по организации с номером <введенный номер> не найдено".]]></description>
    </test>
    <test id="233" subject="Вариант 10. Работа со структурированными данными в файлах" testSetFolder="Variant10">
      <description><![CDATA[В текстовом файле (input.txt, кодировка 1251) содержатся результаты соревнований. 
+Например+,
<pre>
"Иванов","154,1 балла"
"Кузнецов","153,1 балла"
"Петров","155,4 баллов"
"Сидоров","156 баллов"
</pre>
Определить участника, набравшего наибольшее число баллов.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
Формат вывода:
"Победитель - Сидоров - 156 баллов", форму слова "баллов" (1 балл, 2 балла, 6 баллов и т.д. Вам необходимо подобрать самостоятельно) или "Победителя не найдено" при равенстве баллов. 
]]></description>
    </test>
    <test id="234" subject="Вариант 11. Работа со структурированными данными в файлах" testSetFolder="Variant11">
      <description><![CDATA[В текстовом файле (кодировка 1251) содержится балансовая ведомость. Файл представлен в следующем виде.
<pre>
"+125руб"
"-500руб"
"+334руб 00 коп"
"-74   руб 75 коп"
...
</pre>
Требуется определить остаток средств на счету, при условии, что начальный баланс был "+100р".
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Финальный баланс счета Х руб. Y коп."
]]></description>
    </test>
    <test id="235" subject="Вариант 14. Работа со структурированными данными в файлах" testSetFolder="Variant14">
      <description><![CDATA[В текстовом файле (input.txt, кодировка UTF-8) содержатся показания осциллографа, файл представлен следующим образом.
+Например+:
<pre>
0,222345;
0.333456;
1,234522;0,223453
1.234522;0,223453;   0,223453
0.333456;
...
</pre>
Найти среднее значение показаний прибора.
Результат программы (результат или текст ошибки) сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
Среднее показание осциллографа = XX]]></description>
    </test>
    <test id="236" subject="Вариант 20. Работа со структурированными данными в файлах" testSetFolder="Variant20">
      <description><![CDATA[В текстовом файле содержится данные о машинах гаража,  марка и год выпуска структурированы следующим образом
+Например,+
<pre>
машина1: марка="Жигули" год_выпуска=2003  
машина2: марка="Ауди" год_выпуска=  2014
машина3: марка="Форд" год_выпуска=  2014
...
</pre>
Требуется найти средний возраст всех машин гаража.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Средний возраст машин гаража ХХ лет"
]]></description>
    </test>
    <test id="237" subject="Вариант 21. Работа со структурированными данными в файлах" testSetFolder="Variant21">
      <description><![CDATA[В текстовом файле содержится данные о соотрудниках отдела, ФИО, срок службы. 
Например,
соотрудник:[ФИО:"Иванов И.Э."],[стаж:5,5]
соотрудник:[ФИО:"Петроа У.М."],[стаж:4]
соотрудник:[ФИО:"Сидоров Е.Л."],[стаж:3]
...
Требуется найти соотрудника с максимальным стажем работы.]]></description>
    </test>
    <test id="238" subject="Вариант 13. Работа со структурированными данными в файлах" testSetFolder="Variant13">
      <description><![CDATA[В текстовом файле ( input.txt, кодировка utf-8) содержится список игроков и их принадлежность к командам, файл представлен следующим образом:
<pre>
name="Иванов",team="Спартак"
name="Петров",team="ЦСКА"
name="Сидоров",team="Спартак"
name="Кузнецов",team="Шайба"
...
</pre>
Необходимо вывести всех игроков команды, название которой пользователь вводит с клавиатуры.
Результат программы сохраняется в файл ouput.txt (кодировка utf-8).
В случае некорректной записи, ее необходимо игнорировать, продолжая работу программы, выводя в лог ее содержимое и сообщение об ошибке.
+Формат вывода:+
"Список игроков команды <Спартак>:  Иванов, Сидоров" или "Команда ХХХ не найдена".]]></description>
    </test>
  </homework>
  <homework name="Курсовая работа - python">
    <test id="239" subject="Курсовая работа" testSetFolder="Kursovayarabota">
      <description><![CDATA[1. Выбрать себе не занятый веб-ресурс для работы, записать его сюда:
https://docs.google.com/spreadsheets/d/1gTPskly0F9bWOzL2IJI-skCJIwSpPu4d1StKmhIxWLQ/edit?usp=sharing
Выбирать можно из:
- новостных ресурсов
- библиотечных ресурсов
- базы данных научных статей
- wikipedia
- социальные сети
2. С помощью библиотеки Selenium или отправки GET-POST запросов получить с выбранного ресурса максимум текстовой информации(1000+ статей). Произведя разбор полученных страниц, выделить текст статей. В статьях сохранять название, автора(если доступно), тематику(если доступно), другие доступные признаки.
3. Сохранить эти тексты в формате xml, описание формата:
<doc> – корневой тег
<category> – категория, дерево через / (Пример: Медицина/Стоматология)
<author> – автор
<title> – название
<keywords> – ключевые слова автора
<...> - другие опциональные теги
<text><![CDATA[ </text> - текст статьи, обернутый в CDATA
4. Подготовить пояснительную записку, оформление соответствует дипломному(пример на стене на кафедре).
Структура работы:
-Титульный лист
-Лист задания
-Содержание
-Постановка задачи
-Анализ (описание и структура ресурса)
-Проектирование
-Реализация
-Результаты (выводы)
-Список литературы
5. Проверяться на защите будет: результаты работы (xml-файлы), код программы, пояснительная записка (правильно оформленная и подшитая).
Пример xml файла.
http://textanalysis.ru/3/example.xml
Соответственно текст статьи надо заключить в CDATA, остальные необязательные теги - старайтесь вытащить с ресурса по максимуму, заключать их в [CDATA] необязательно
Атрибуты для автоматически выделенных значений:
auto="true" type="str" verify="true"
type еще бывает "list", пример в списке авторов.
Код инструмента и результаты работы прикладывайте к задаче редмайн.
Пояснительная записка должна содержать(названия пунктов приблизительные):
"Разработка инструмента автоматического сбора информации из открытых источников сети Интернет."
1. Введение
2. Описание задачи
3. Описание инструментов / алгоритмов
4. Описание(анализ) результатов
5. Список литературы.
Оформление аналогично дипломам (см стенд в 608й или http://textanalysis.ru/files/example.doc)
]]>
	  </description>
    </test>
  </homework>
  <homework name="Потоки и процессы">
    <test id="240" subject="Результаты сессии" testSetFolder="Rezultatysessii">
      <description><![CDATA[Преподаватель Алексей реализует программу, которая должна подсчитать результаты студентов за семестр. Он реализовал ее на языке C++, но она собирает много данных и работает долго, около двух минут. 
Результаты программа выводит в консоль в виде:
<pre>
Иванов - отлично 
Петров - хорошо
</pre>
Вам нужно запустить эту программу в отдельном процессе из папки, лежащей рядом с вашей программой(get_results.exe), дождаться ее результатов и рассчитать средний балл по группе.
Вывести его в виде, с округлением до 2х знаков:
<pre>
Average: 4.75
</pre>]]></description>
    </test>
    <test id="241" subject="Кто первый" testSetFolder="Ktopervyi">
      <description><![CDATA[Одна их переменных в программе равна 1000.
Создайте в программе 2 потока, один уменьшает ее на 2, второй, увеличивает на единицу.
Если переменная стала 1010 - победил первый, ноль - победил второй.
Распечатайте какой поток "победил".]]></description>
    </test>
    <test id="242" subject="Чтение файлов" testSetFolder="Chteniefailov">
      <description><![CDATA[В каталоге Data рядом вашей с программой лежат текстовые файлы. Они большого размера и их много. Из них нужно вычитать все цифры (положительные и отрицательные, все они целые), кроме цифр в файлах есть произвольный текст.
Ваша задача состоит в том, чтобы найти сумму всех этих цифр, разумеется, чтобы уложиться в разумное время (~2-3 секунды) программе надо будет сделать это в несколько потоков.
Выведите одно число - получившуюся сумму.]]></description>
    </test>
  </homework>
  <homework name="Selenium">
    <test id="243" subject="Прибыль компаний за год" testSetFolder="Pribylkompaniizagod">
      <description><![CDATA[h2. В сети появился отчет о прибыли по компаний за прошлый год.
Отчет доступен тут:
https://bit.ly/tableOfIncome
При помощи Selenium & xPath запросов (обязательно, кроме того, старайтесь мимимизировать число запросов, составляя запрос так, чтобы нужная информация возвращалась сразу) необходимо вытащить со страницы, распечатать в консоли и ввести данные в соответствующие формы:
*Задача один*: определить прибыль компании Microsoft в третьем квартале. (Или вывести 0, если Microsoft отсутствует в отчете)
*Задача два*: определить самую успешную компанию по итогам года.
*Задача три*: определить самый прибыльный квартал (ввести, например, "q3").
*Задача четыре*: получить  3 значения "Верно!" в полях ввода и сделать соответствующий скриншот.
Скриншот нужно приложить к задаче вместе с исходным кодом на Python.]]></description>
    </test>
    <test id="244" subject="Актуальный курс доллара" testSetFolder="Aktualnyikursdollara">
      <description><![CDATA[На странице https://quote.rbc.ru/ в верхней части отображается текущий курс обмена наличного доллара на рубли.
!https://image.ibb.co/iGtaXS/Quote.png!
Требуется с использованием Selenium Web Driver написать Python скрипт, который распечатает в консоль текущий курс покупки и продажи наличного доллара.
Замечание 1: Рекомендуется использование xPath
Замечание 2: Переборные решения тут возможны, но будут оценены ниже. Старайтесь избегать привязки к порядку следования элементов на странице.]]></description>
    </test>
  </homework>
  <homework name="http-запросы xml">
    <test id="245" subject="Сортировка xml файла" testSetFolder="processAndSortXml">
      <description><![CDATA[Вашей программе на вход в качестве параметра запуска поступают .xml файлы - "input.xml" и "settings.xml"
Формат settings.xml
<pre>
<settings>
    <array name="SomeArrayName"/>
    <attributeName value="SomeValue" />
<settings/>
</pre>
Среди элементов входного файла найдется группирующий тег <SomeArrayName>, в котором будут произвольные по именам элементы с аттибутом "SomeValue".
Вам требуется записать в выходной xml файл - output.xml копию input.xml, в котором элементы внутри someArray будут отсортированы по значению SomeValue.
+Пример:+
*Файл с настройками:*
<pre>
<settings>
    <array name="BookStore"/>
    <attributeName value="Author" />
<settings/>
</pre>
*Входной файл:*
<pre>
<xml>
<MyStoreDescription>This is my best store!
</MyStoreDescription>
<MyBooksCollection value="NotForResale"/>
<BookStore>
    <Book Author="Pushkin" Name="Captains Daughter"/>
    <Book Author="Lermontov" Name="Mtsyry"/>
</BookStore>
</xml>
</pre>
*Выходной файл:*
<pre>
<xml>
<MyStoreDescription>This is my best store!
</MyStoreDescription>
<MyBooksCollection value="NotForResale"/>
<BookStore>
    <Book Author="Lermontov" Name="Mtsyry"/>
    <Book Author="Pushkin" Name="Captains Daughter"/>
</BookStore>
</xml>
</pre>]]></description>
    </test>
    <test id="246" subject="Погода на завтра" testSetFolder="Pogodanazavtra">
      <description><![CDATA[Сервис https://www.meteoservice.ru/content/export
предоставляет данные о погоде в любой точке России.
Вам нужно с использованием только HTTP запросов(без средств Selenium'a) по введенному в консоли населенному пункту России, получить xml файл с прогнозом и рассчитать и вывести по нему среднюю температуру на "завтра".
Подсказка: изучайте структуру страницы, там все очевидно.
Пример:
Ввод:
Москва
Загружается xml для Москвы:
<pre>
<MMWEATHER>
<script/>
<script/>
<REPORT type="frc3">
<TOWN index="7224" sname="%D0%90%D0%B1%D0%B0%D0%B7%D0%B0%2C+%D0%A0%D0%B5%D1%81%D0%BF.+%D0%A5%D0%B0%D0%BA%D0%B0%D1%81%D0%B8%D1%8F%2C+%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F" latitude="53" longitude="90">
<FORECAST day="22" month="04" year="2020" hour="21" tod="3" predict="0" weekday="4">
<PHENOMENA cloudiness="0" precipitation="10" rpower="0" spower="0"/>
<PRESSURE max="764" min="763"/>
<TEMPERATURE max="21" min="7"/>
<WIND min="0" max="1" direction="1"/>
<RELWET max="47" min="17"/>
<HEAT min="4" max="4"/>
</FORECAST>
<FORECAST day="23" month="04" year="2020" hour="03" tod="0" predict="0" weekday="5">
<PHENOMENA cloudiness="0" precipitation="10" rpower="0" spower="0"/>
<PRESSURE max="764" min="764"/>
<TEMPERATURE max="7" min="1"/>
<WIND min="0" max="1" direction="5"/>
<RELWET max="81" min="47"/>
<HEAT min="-3" max="-3"/>
</FORECAST>
<FORECAST day="23" month="04" year="2020" hour="09" tod="1" predict="0" weekday="5">
<PHENOMENA cloudiness="0" precipitation="10" rpower="0" spower="0"/>
<PRESSURE max="764" min="762"/>
<TEMPERATURE max="17" min="1"/>
<WIND min="1" max="1" direction="5"/>
<RELWET max="82" min="29"/>
<HEAT min="-2" max="-2"/>
</FORECAST>
<FORECAST day="23" month="04" year="2020" hour="15" tod="2" predict="0" weekday="5">
<PHENOMENA cloudiness="0" precipitation="10" rpower="0" spower="0"/>
<PRESSURE max="762" min="760"/>
<TEMPERATURE max="26" min="20"/>
<WIND min="1" max="1" direction="6"/>
<RELWET max="24" min="13"/>
<HEAT min="18" max="18"/>
</FORECAST>
</TOWN>
</REPORT>
</MMWEATHER>
</pre>
Вывод(среднее значение температуры на завтра, 23 апреля):
12]]></description>
    </test>
  </homework>
  <homework name="Python финальный зачет_xml_selenium">
    <test id="247" subject="Секретные коды доступа к данным &quot;квадрогона&quot;" testSetFolder="finalQuadCodes">
      <description><![CDATA[В одной заморской стране, в которой наделы земли треугольные, главный секретный штаб обороны имеет форму четырехугольника, и поэтому называется "квадрогоном". Разграничение доступа к его данным - очень ответственная задача. Ее и решал разработчик Василий. Вот что он придумал:
Для доступа используется имя и фамилия сотрудника, на первом этапе, передаются GET параметры запроса к системе идентификации первого уровня.
http://textanalysis.ru/3/index.php
Требуется передать параметрами Ваше имя (first) и фамилию (second). 
При этом система предоставит временные коды доступа для второго эшелона защиты.
Эти временные коды необходимо передать в заголовках (first, second, third) на страницу
http://textanalysis.ru/3/index.php
Если всё хорошо, страница предоставит вам код доступа к данным "квадрогона". Ваша цель достигнута. 
Нужно распечатать этот код.
Тестирующая программа же проверит доступ к данным "квадрогона" и скажет Вам спасибо.]]></description>
    </test>
    <test id="248" subject="Снова курсы валют" testSetFolder="Snovakursyvalyut">
      <description><![CDATA[На странице Центробанка существует сервис проверки курсов валют, сервис принимает GET запросы.
(http://www.cbr.ru/scripts/XML_daily.asp)
Задача: 
Определить самую дорогую валюту в перерасчете на 1 рубль.]]></description>
    </test>
    <test id="249" subject="Погода на каникулах после сессии" testSetFolder="Pogodanakanikulahposlesessii">
      <description><![CDATA[На странице https://gismeteo.ru доступен прогноз погоды в любой точке мира.
С помощью Selenium WebDriver загрузите указанную страницу. Далее в строке поиска найдите Тенерифе (интересует погода в любой части острова).
Затем выберите прогноз на месяц и выведите в консоль прогноз(максимальную температуру) на 12 июня.
Чем аккуратнее и надежнее будет сделан выбор погоды на месяц и даты, тем выше оценка за задачу.]]></description>
    </test>
    <test id="250" subject="Проверка доменного имени" testSetFolder="Proverkadomennogoimeni">
      <description/>
    </test>
    <test id="251" subject="Центробанк устанавливает курс - 2" testSetFolder="Centrobankustanavlivaetkurs2">
      <description><![CDATA[На странице Центробанка существует сервис проверки курсов валют, сервис принимает GET запросы.
(http://www.cbr.ru/scripts/XML_daily.asp)
Задача: 
Перевести 100руб. во все валюты стран, которые называются "доллар" вывести:
100 руб по курсу на <date>:
xx в валюте "Канадский доллар"
yy в валюте "Доллар США" 
...
(Количество валют может быть различным, зависит от того, какие обменные курсы поддерживает ЦБ в настоящий момент)]]></description>
    </test>
    <test id="252" subject="Центробанк устанавливает курс" testSetFolder="Centrobankustanavlivaetkurs">
      <description><![CDATA[На странице Центробанка существует сервис проверки курсов валют, сервис принимает GET запросы.
(http://www.cbr.ru/scripts/XML_daily.asp)
Задача: 
Перевести 100руб. в чешские кроны по курсу на _текущую дату_.
Вывод программы:
100 руб по курсу на *21 мая 2022* года в валюте "чешские кроны" составляет xxx.
Результат округлить до двух знаков после запятой.]]></description>
    </test>
  </homework>
  <homework name="Python финальный зачет_xml_selenium_2">
    <test id="253" subject="Сортировка данных в XML-файле" testSetFolder="processAndSortXml">
      <description><![CDATA[Вашей программе на вход в качестве параметра запуска поступают .xml файлы - "input.xml" и "settings.xml"
Формат settings.xml
<pre>
<settings>
    <array name="SomeArrayName"/>
    <attributeName value="SomeValue" />
<settings/>
</pre>
Среди элементов входного файла найдется группирующий тег <SomeArrayName>, в котором будут произвольные по именам элементы с аттибутом "SomeValue".
Вам требуется записать в выходной xml файл - output.xml копию input.xml, в котором элементы внутри someArray будут отсортированы по значению SomeValue.
+Пример:+
*Файл с настройками:*
<pre>
<settings>
    <array name="BookStore"/>
    <attributeName value="Author" />
<settings/>
</pre>
*Входной файл:*
<pre>
<xml>
<MyStoreDescription>This is my best store!
</MyStoreDescription>
<MyBooksCollection value="NotForResale"/>
<BookStore>
    <Book Author="Pushkin" Name="Captains Daughter"/>
    <Book Author="Lermontov" Name="Mtsyry"/>
</BookStore>
</xml>
</pre>
*Выходной файл:*
<pre>
<xml>
<MyStoreDescription>This is my best store!
</MyStoreDescription>
<MyBooksCollection value="NotForResale"/>
<BookStore>
    <Book Author="Lermontov" Name="Mtsyry"/>
    <Book Author="Pushkin" Name="Captains Daughter"/>
</BookStore>
</xml>
</pre>]]></description>
    </test>
  </homework>
  <homework name="Настройка Python">
    <test id="254" subject="Разминка" testSetFolder="Razminka">
      <description><![CDATA[Цель - установить python(www.python.org), PyCharm(или другую IDE) и научиться работать с Redmine.
Справка:
Начало работы над задачей
Начав работу над задачей, поменять статус задачи на In Progress.
Отправка на проверку
Для загрузки кода задачи в систему нужно прикрепить файл исходного кода (*.java, *.py и т.д.) в соответствующую задачу в системе, если файлов несколько, их следует предварительно упаковать в .zip архив.
Для отправки на проверку статус задачи нужно поменять на Assigned или Resolved и перевести задачу на меня.
Проверка
Наличие ошибок в оформлении кода - задача переводится на автора со статусом Assigned, добавляется отчет о результатах проверки.
Наличие ошибок в решении - задача переводится на автора со статусом Assigned, добавляется отчет о результатах проверки.
Правильное оформление кода и решение задачи - задача переводится на автора со статусом Closed/Approved]]></description>
    </test>
  </homework>
  <homework name="Задача_перебор_алфавита">
    <test id="255" subject="Алфавит" testSetFolder="alfavit">
      <description><![CDATA[Вводятся 2 строки : например,  “aaa” и “abd” одинаковой длины. Нужно вывести полный перебор строк от первой до второй в алфавитном порядке, т.е.
aaa
aab
aac
...
aaz
aba
...
abd]]></description>
    </test>
  </homework>
  <homework name="домашняя_работа Git">
    <test id="256" subject="Командная разработка" testSetFolder="Komandnayarazrabotka">
      <description><![CDATA[Учимся командной разработке:
Есть общий проект:
https://github.com/zerg0s/LetsLearnGit
В нем пока только главный файл.
Требуется:
1. Решить задачу "алфавит" из https://www.hostedredmine.com/issues/935704
2. Свое решение  реализовать в виде функции отдельном файле 
3. Сделать вызов вашего решения в основном файле, посмотрите, сделайте по аналогии.
4. Решение этой задачи - правильно сформированный (нужна ссылка в задаче в Redmine) и принятый pull request в этом репозитории GIT'a
Оцениваться будет 0-10 в зависимости от соблюдения всех правил создания коммитов и качества кода.]]></description>
    </test>
  </homework>
  <homework name="Django table">
    <test id="257" subject="My first Django table" testSetFolder="MyfirstDjangotable">
      <description><![CDATA[Вам нужно создать проект на Django, в котором при обращении к странице 
.../api/get
возвращается список студентов и их срений балл в json формате.
а по вызову страницы - 
../students
показывается страница с аналогичной визуальной html-таблицей.
Cам список студентов хранится в sqlite базе данных.]]></description>
    </test>
    <test id="9274" subject="Просто тестовая задача" testSetFolder="">
      <description><![CDATA[ыва]]></description>
    </test>
  </homework>
  <homework name="Сериализация и десериализация">
    <test id="262" subject="Гостиницы на картах Google" testSetFolder="serial_gmaps">
      <description><![CDATA[Вашей программе на вход(надо читать входящий поток) поступают данные в виде Json-объекта из сервиса Google Maps о отелях и их координатах на карте.
Например: 
{
  "markers": [
    {
      "name": "Rixos The Palm Dubai",
      "position": [25.1212, 55.1535],
    },
    {
      "name": "Shangri-La Hotel",
      "location": [25.2084, 55.2719]
    },
    {
      "name": "Grand Hyatt",
      "location": [25.2285, 55.3273]
    }
  ]
}
Вам требуется: 
Определить название самого западного отеля и распечатать его.
Для примера из условия необходимо распечатать:
Rixos The Palm Dubai.]]></description>
    </test>
    <test id="263" subject="Хранение данных о сотрудниках" testSetFolder="serial_employees">
      <description><![CDATA[Вам дан класс, в объектах которого информационная система хранит информацию о сотрудниках:
<pre>
class Salary:
    def init(self):
        self.amount = 100
        self.currency = "USD"
class Employee:
    def init(self, aBoss=None):
        self.name = "someName"
        self.age = 25
        self.position = "Unknown"
        self.salary = Salary()
        self.availableRooms = list()  # комнаты, которые открывает пропуск сотрудника
</pre>
Вам нужно реализовать эти 2 класса, main и считать из входящего потока данные о сотрудниках в CSV:
Например,
Ivanov, 25, developer, 100500, peso, 12, 14, 15 
Petrov, 23, analyst, 100, rupee, 10
(количество комнат, куда он мог бы попасть - произвольное, в т.ч. может отсутствовать для уволенных сотрудников, в таком случае надо выводить null в Json объекте)
Далее распечатать Json-объект в одну строку, следующим образом:
<pre>
{"Employee": {"name": "Ivanov", "age": 25, "position": "developer", "salary": {"amount": 100500, "currency": "peso"}, "availableRooms": [12, 14, 15]}} {"Employee": {"name": "Petrov", "age": 23, "position": "analyst", "salary": {"amount": 100, "currency": "rupee"}, "availableRooms": [10]}}
</pre>]]></description>
    </test>
    <test id="264" subject="Кто там в десятой комнате" testSetFolder="serial_room_ten">
      <description><![CDATA[На вход вам поступает список Json-объектов из предыдущей задачи:
[
  {"Employee": {"name": "Ivanov", "age": 25, "position": "developer", "salary": {"amount": 100500, "currency": "peso"}, "availableRooms": [10, 14, 15]}},
  {"Employee": {"name": "Petrov", "age": 23, "position": "analyst", "salary": {"amount": 100, "currency": "rupee"}, "availableRooms": [10]}},
	{"Employee": {"name": "Van Petrov", "age": 23, "position": "analyst", "salary": {"amount": 100, "currency": "rupee"}, "availableRooms": null}}
]
Вам необходимо создать у себя в коде программы список объектов класса Employee, назвав его "employees". Далее распечатать в порядке появления в исходном списке через запятую всех, у кого есть доступ в комнату 10 или "No", если таковых нет.
Для примера из условия:
Ivanov, Petrov]]></description>
    </test>
  </homework>
  <homework name="Контрольная работа номер 3">
    <test id="265" subject="JsonSerializer class" testSetFolder="classJsonSerializer">
      <description><![CDATA[Данные часто нужно сериализовывать, то есть превращать в строку. Это нужно для сохранения на диске, для отправки по сети, для передачи другому процессу. Часто для этого используются несколько общепринятых форматов данных, таких как JSON, YAML, XML. Поскольку не всегда известно, в каком именно формате надо сериализовывать данные, часто приходится прибегать к наследованию. Вам дан  класс Serializer со следующими методами:
<pre>
 class Serializer:
    def beginArray(self):
        raise NotImplementedError("BeginArray is not implemented")
    def addArrayItem(self, item):
        raise NotImplementedError("addArrayItem is not implemented")
    def endArray(self):
        raise NotImplementedError("endArray is not implemented")
</pre>
После этого унаследуйте от него класс JsonSerializer, определив все эти методы.
JsonSerializer должен печатать упрощенную версию JSON'а (https://ru.wikipedia.org/wiki/JSON), состояющую только из массивов и строк. Массив начинается с квадратной скобки. После каждого элемента, кроме последнего, должна стоять запятая. Заканчивается массив квадратной скобкой. Все строки должны быть взяты в двойные кавычки. Гарантируется, что все строки состоят только из латинских символов и пробелов, поэтому экранировать их не надо.
Сдавать необходимо только код класса JsonSerializer (c родительским классом), без main. 
Вам не нужно заботиться о вводе, это реализовано в тестирующей программе.
*Пример 1*
Ввод  
BeginArray
EndArray
Вывод
[]
*Пример 2*
Ввод  
BeginArray
AddArrayItem string
EndArray
Вывод
["string"]
*Пример 3*
Ввод  
BeginArray
AddArrayItem first
AddArrayItem second
EndArray
Вывод
["first","second"]
*Пример 4*
Ввод  
BeginArray
BeginArray
EndArray
EndArray
Вывод
[[]]]]>
</description>
    </test>
    <test id="266" subject="Простые числа в функциональном стиле" testSetFolder="funcSimpleNumbers">
      <description><![CDATA[Решение необходимо оформить в одну инструкцию языка Python
Выведите все простые на отрезке [2; n].
Формат ввода
Вводится число .
Формат вывода
Выведите все простые числа из отрезка [2, n] в порядке возрастания
Пример 1
Ввод
8
Вывод
2 3 5 7
Пример 2
Ввод 
10
Вывод
2 3 5 7
Пример 3
Ввод  
5
Вывод
2 3 5
Примечания
Напомним, что проверить число на то, простое ли оно можно за количество операций порядка порядка sqrt(x).]]></description>
    </test>
    <test id="267" subject="Наш общий предок" testSetFolder="kr3LowestCommonAncestor">
      <description><![CDATA[Изначально имеется дерево, состоящее только из корня (Вершина с именем - "1"). Требуется написать программу, отвечающую на следующие запросы:
*ADD a b*
Добавить к вершине _а_ новую вершину _b_ . Корректность данных гарантируется.
*GET a b* 
Распечатать имя вершины, из которой можно попасть по дереву в вершины _a_ и _b_ за суммарно минимальное число шагов. Корректность данных гарантируется.
Имена вершин могут быть любыми строками без пробелов.
В первой строке ввода содержится целое цисло - количество "запросов" к дереву. Далее идут сами запросы.
*Пример 1*
Ввод:
3
ADD 1 2
ADD 1 3
GET 2 3
Вывод:
1
*Пример 2:*
Ввод:
9
ADD 1 2
ADD 1 3
ADD 2 4
GET 1 3
GET 2 3
GET 3 4
ADD 2 5
GET 4 5
GET 5 5
Вывод:
1
1
1
2
5]]></description>
    </test>
  </homework>
  <homework name="Рекурсия">
    <test id="9268" subject="Ханойская башня" testSetFolder="recursionHanoi">
      <description><![CDATA[_В общем случае наилучшее применение рекурсии - это решение задач, для которых свойственна одна черта: решение задачи в целом сводится к решению подобной же задачи, но меньшей размерности и, следовательно, легче решаемой._
Легенда гласит, что где-то в Ханое находится храм, в котором размещена следующая конструкция: на основании укреплены 3 алмазных стержня, на которые при сотворении мира Брахма нанизал 64 золотых диска с отверстием посередине,  причем внизу оказался самый большой диск, на нем  чуть меньший и так далее, пока на верхушке пирамиды не оказался самый маленький диск. Жрецы храма обязаны перекладывать диски по следующим правилам:
За один ход можно перенести только один диск.
Нельзя класть больший диск на меньший.
Руководствуясь этими нехитрыми правилами, жрецы должны перенести исходную пирамиду с 1-го стержня на 3-й. Как только они справятся с этим заданием, наступит конец света.
Итак, решаем обобщенную задачу: как перенести пирамиду из *n* колец со стержня *i* на стержень *j* , пользуясь стержнем *k* как вспомогательным? Эта задача решается следующим образом:
Перенести (n-1) кольцо с i на k.
Перенести 1 кольцо с i на j.
Перенести (n-1) кольцо с k на j.
*Входные данные* : число колец, которые вам нужно перенести с первого стержня на второй
*Выходные данные* : последовательность шагов в виде "номер кольца, стержень откуда, стержень куда", приводящая к решению задачи. 
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного числа дисков.
Нумеровать кольца будем от меньшего к большему.
Пример:
Ввод:
2
Вывод:
1 1 3
2 1 2
1 3 2]]></description>
    </test>
    <test id="9269" subject="Теорема Лагранжа" testSetFolder="recursionLagrange">
      <description><![CDATA[Теорема Лагранжа утверждает, что любое натуральное число можно представить в виде суммы четырех точных квадратов. По данному числу n найдите такое представление: напечатайте от 1 до 4 натуральных чисел, квадраты которых дают в сумме данное число.
Формат ввода
Программа получает на вход одно натуральное число n < 10000.
Формат вывода
Программа должна вывести от 1 до 4 натуральных чисел, квадраты которых дают в сумме данное число.
*Пример 1*
Ввод	
1
Вывод
1 
*Пример 2*
Ввод	
2
Вывод
1 1 
*Пример 3*
Ввод	
11
Вывод
3 1 1
*Пример 4*
Ввод	
4
Вывод
2 ]]></description>
    </test>
    <test id="9270" subject="Быстрое возведение в степень" testSetFolder="recursionQuickPow">
      <description><![CDATA[Оказывается, возводить в степень можно гораздо быстрее, чем за *n* умножений! 
Для этого нужно воспользоваться следующими рекуррентными соотношениями: 
a^n=(a^2)^(n/2), при четном n, 
a^n= a * a^(n-1), при нечетном n. 
Реализуйте алгоритм быстрого возведения в степень. Если вы все сделаете правильно, то сложность вашего алгоритма будет O(log n)
Вводится действительное число a и целое число n.
Запрещается пользоваться циклами, функцией pow и оператором возведения в степень.]]></description>
    </test>
    <test id="9271" subject="Произвольное количество вложенных циклов" testSetFolder="recursionInnnerLoops">
      <description><![CDATA[Разместив рекурсивные вызовы внутри цикла, по сути, получим вложенные циклы, где уровень вложенности равен глубине рекурсии.
Требуется разработать функцию, печатающую все возможные сочетания из k чисел от 1 до n !http://s0.wp.com/latex.php?latex=%5Cmathrm%7BC%7D_n%5Ek&bg=ffffff&fg=000000&s=0! . Числа, входящие в каждое сочетание, нужно печатать в порядке возрастания. Сочетания из двух чисел (k=2) печатаются так:
<pre>
for i in range(n):
    for i1 in range(n):
        print(i, i1)
</pre>
Сочетания из трех чисел (k=3) так:
<pre>
for i in range(n):
    for i1 in range(n):
        for i2 in range(n):
            print(i, i1, i2)
</pre>
Однако, если количество чисел в сочетании задается переменной, то придется прибегнуть к рекурсии.
n, k - подаются на вход 
Необходимо распечатать все сочетания !http://s0.wp.com/latex.php?latex=%5Cmathrm%7BC%7D_n%5Ek&bg=ffffff&fg=000000&s=0!
*Пример 1* 
Ввод
2 3
Вывод
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1
*Пример 2* 
Ввод
1 3
Вывод
0 0 0]]></description>
    </test>
    <test id="9272" subject="Сократите дробь" testSetFolder="recursionDivisionDeduction">
      <description><![CDATA[Даны два натуральных числа *n* и *m* . Сократите дробь n/m, то есть нужно вывести два других числа *p* и *q* таких, что  и дробь  p/q — несократимая. 
Решение оформите в виде функции reduceFraction(n, m), получающей значения n и m и возвращающей кортеж из двух чисел. 
Читать и петатать ответ в вашей программе должен main, функция должна только реализовывать решение задачи.
*Пример 1*
Ввод	
12
16
Вывод
3 4
*Пример 2*
Ввод	
9
7
Вывод
9 7
*Пример 3*
Ввод	
10
100
Вывод
1 10]]></description>
    </test>
    <test id="9273" subject="Сумма последовательности" testSetFolder="recursionSumOfSequence">
      <description><![CDATA[Дана последовательность чисел, завершающаяся числом 0. Вычислите ее сумму в виде рекурсивной функции.
Формат ввода
Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
Формат вывода
Выведите ответ на задачу.
*Пример 1*
Ввод	
1
7
9
0
Вывод
17]]></description>
    </test>
  </homework>
  <homework name="Бинарные деревья">
    <test id="8280" subject="Инвертирование бинарного дерева" testSetFolder="classTreeDepth">
      <description><![CDATA[Вам дано бинарное дерево, представленное классом:
<pre>
class TreeNode(object):
     def init(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
</pre>
Вам нужно c помощью этого класса написать функцию, которая инвертирует все дочерние узлы для каждого элемента этого бинарного дерева, как показано на рисунке.
Пример сигнатуры функции:
<pre>
from TreeNode import TreeNode
def invertTree(root):
    return TreeNode()
</pre>
!https://i.ibb.co/2MjWKXt/invert1-tree.jpg!
Вам нужно сдавать только функцию invertTree, которая импортирует TreeNode.]]></description>
    </test>
    <test id="9281" subject="Максимальная глубина бинарного дерева" testSetFolder="classTreeMaxDepth">
      <description><![CDATA[Вам дано бинарное дерево, представленное классом:
<pre>
class TreeNode(object):
     def init(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
</pre>
Вам нужно c помощью этого класса написать функцию, которая вычисляет максимальную глубину этого бинарного дерева, как показано на рисунке, для дерева на рисунке ответ - 3.
Пример сигнатуры функции:
<pre>
from TreeNode import TreeNode
def maxDepth(root):
    return 0
</pre>
!https://i.ibb.co/Wn9Mr62/tmp-tree-max.jpg!
Вам нужно сдавать только функцию maxDepth, которая импортирует TreeNode.]]></description>
    </test>
    <test id="9282" subject="Сумма чисел в бинарном дереве" testSetFolder="classTreeSumOfNumbers">
      <description><![CDATA[Вам дано бинарное дерево, представленное классом:
<pre>
class TreeNode(object):
     def init(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
</pre>
Вам нужно c помощью этого класса написать функцию, которая вычисляет сумму числе, составленную из всех путей корень->лист, для дерева на рисунке ответ - 1026.
Первый возможный путь корень->лист 4->9->5 представляет число 495.
Второй возможный путь корень->лист 4->9->1 представляет число  491.
Первый возможный путь корень->лист 4->0 представляет число 40.
Поэтому, их сумма = 495 + 491 + 40 = 1026.
В узлах могут быть цифры 0-9.
Пример сигнатуры функции:
<pre>
from TreeNode import TreeNode
def sumOfTree(root):
    return 0
</pre>
!https://i.ibb.co/FD6Y8T2/num2tree.jpg!
Вам нужно сдавать только функцию sumOfTree, которая импортирует TreeNode.]]></description>
    </test>
    <test id="9283" subject="Проверка полноты бинарного дерева" testSetFolder="classTreeCheckCompleteness">
      <description><![CDATA[Вам дано бинарное дерево, представленное классом:
<pre>
class TreeNode(object):
     def init(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
</pre>
Вам нужно c помощью этого класса написать функцию, которая проверяет является ли бинарное дерево "полноценным".
"Полноценным" назовем такое бинарное дерево, в котором на каждом уровне, возможно за исключением последнего, заполнены все элементы. И элементы последнего уровня находятся как можно левее.
Пример сигнатуры функции:
<pre>
from TreeNode import TreeNode
def isCompleteTree(root):
    return True
</pre>
Пример 1:
!https://i.ibb.co/pPVhF7g/complete-binary-tree-1.png!
Результат: True
На всех уровнях, кроме последнего заполнены все элементы. На последнем элементы располагаются строго "слева направо".
Пример 2:
!https://i.ibb.co/gWwy1H4/complete-binary-tree-2.png!
Результат: False
Последний элемент должен быть слева, а не справа, дерево проверку не прошло.
Вам нужно сдавать функцию isCompleteTree, которая импортирует TreeNode. Другие функции - по желанию.]]></description>
    </test>
  </homework>
</AllTestDescription>
